---
title:  牛客网前端题库详解
date: 2021-06-02 21:07:33
categories: 
- web前端
tags:
- 牛客网
- 前端
- 题库
---

很快，又要到了秋招时刻，牛客网这个[前端笔试题库](https://www.nowcoder.com/activity/oj?tab=3)，可以说这60道是前端最基础的了，也是考察的东西比较杂，有时间4天差不多就可以刷完，巩固基础还是有些用的。做完题回顾一上午就可以过完一遍。现在我结合我的答案和参考的其他人的答案，在这里做一个总结，也是自己知识的整理结果。
<!-- more -->

### 1. [修改 this 指向](https://www.nowcoder.com/practice/a616b3de81b948fda9a92db7e86bd171)

#### 问题描述

> 封装函数 f，使 f 的 this 指向指定的对象。

这里给出三种写法，哪种都可以。

#### apply修改this作用域

```js
function bindThis(f, oTarget) {
    return function() {
        return f.apply(oTarget, arguments);
    }
}
```

#### call修改this作用域

```js
function bindThis(f, oTarget) {
    return function() {
        return f.call(oTarget, ...arguments);
    }
}
```

#### bind修改this作用域

注意需要调用函数，bind默认绑定this懒执行

```js
function bindThis(f, oTarget) {
    return function() {
        return f.bind(oTarget, ...arguments)();
    }
}
```

或者直接简写

```js
function bindThis(f, oTarget) {
    return f.bind(oTarget);
}
```

#### 相关知识点

- apply、call、bind区别

> apply、call、bind的作用都是修改执行上下文
> apply、call都是返回函数立即执行的结果，其中apply第二个参数之后是数组，call第二个参数之后是单个的值。
> bind返回的是函数，需要手动执行结果。第二个参数之后是单个的值。

### 2. [获取 url 参数](https://www.nowcoder.com/practice/a3ded747e3884a3c86d09d88d1652e10)

#### 问题描述

> 获取 url 中的参数
>
> 1. 指定参数名称，返回该参数的值 或者 空字符串
> 2. 不指定参数名称，返回全部的参数对象 或者 {}
> 3. 如果存在多个同名参数，则返回数组
>
> 输入：`http://www.nowcoder.com?key=1&key=2&key=3&test=4#hehe key`
>
> 输出：[1, 2, 3]

#### 代码

```js
function getUrlParam(sUrl, sKey) {
    // 返回?后面#前面的
    let sParam = sUrl.split("?")[1].split("#")[0];  //key=1&key=2&key=3&test=4
    // 进一步将参数分割为数组
    let arr = sParam.split("&"); //["key=1","key=2","key=3","test=4"]
    // 结果
    let res;
    if( sKey ){ // 如果指定参数
        // 结果为数组
        res = [];
        for (let i = 0; i < arr.length; i++) {
            // 分割为键值对
            let temp = arr[i].split("=");
            // 存储指定key值的结果
            if(temp[0] === sKey){
                res.push(temp[1]);
            }
        }
        if (res.length === 1) {
            // 长度为1，返回字符串
            return res[0];
        } else if(res.length === 0){
            // 长度为0，返回空字符串
            return "";
        } else {
            // 长度大于1返回数组
            return res;
        }
         
    } else { // 如果不指定参数
        // 结果为对象
        res = {};
        if(sParam === undefined || sParam === "" ){
            return res;
        }
        for (let i = 0; i < arr.length; i++) {
            // 分割为键值对
            let temp = arr[i].split("=");
            // 判断是否已存在结果
            if(!(temp[0] in res)){
                // temp[0]为键，temp[1]的数组为值
                res[temp[0]] = []; 
            }
            // 使用变量动态访问对象属性用obj[a]不能用obj.a
            res[temp[0]].push(temp[1]); 
        }
         
    }
    return res;
}
```

大同小异的做法

```js
function getUrlParam(sUrl, sKey) {
    let newArr = [];
    let newObj = {};
    // 获取?号后面#号前面的值
    let query = sUrl.split("#")[0].split("?")[1];
    // 如果query存在
    if (query) {
        let arr = query.split("&");
        for (let i = 0; i < arr.length; i++) {
            if (arr[i]) {
                arr[i] = arr[i].split("=");
                // 数组
                if (sKey !== undefined) {
                    if (arr[i][0] === sKey) {
                        newArr.push(arr[i][1]);
                    }
                    // 对象
                } else {
                    if (arr[i][0] in newObj) {
                        newObj[arr[i][0]].push(arr[i][1]);
                    } else {
                        newObj[arr[i][0]] = [arr[i][1]];
                    }
                }
            }
        }
        // 判断sKey有没有值
        if (sKey !== undefined) {
            switch (newArr.length) {
                case 0:
                    return "";
                    break;
                case 1:
                    return newArr[0];
                    break;
                default:
                    return newArr;
                    break;
            }
        } else {
            return newObj;
        }
        // 如果query不存在，判断sKey是否存在，如果存在就返回空对象，如果不存在就返回空字符串
    } else {
        return sKey !== undefined ? {} : "";
    }
}
```

#### 相关知识点

- url的组成部分

  > `https://user:pass@www.baidu.com:80/index.html?type=1&name=2#haha`
  > `http/https` 是协议
  > `user:pass@` 是登录认证
  > `www.baidu.com` 是域名，服务器地址
  > `:80` 是端口号
  > `/index.html` 是请求资源文件路径
  > `?type=1&name=2` 是查询字符串，携带参数，给服务器传的内容。
  > `#haha` 是哈希，片段标识符

- split方法

  > 字符串分割成数组的方法，里面的参数是以什么分割，如果不传就是空字符串为分割，返回值是一个数组。

- query部分可以使用正则

### 3. [dom 节点查找](https://www.nowcoder.com/practice/74d74be449af4c66907fe2d6961c255c)

#### 问题描述

> 查找两个节点的最近的一个共同父节点，可以包括节点自身
>
> 输入描述:
> oNode1 和 oNode2 在同一文档中，且不会为相同的节点

#### 代码

```js
function commonParentNode(oNode1, oNode2) {
    // 判断是否为直系节点
    if(oNode1.contains(oNode2)) {
        // oNode1已经是oNode2的直系祖节点
        return oNode1;
    } else {
        // 顺着父节点向上查询
        return commonParentNode(oNode1.parentNode, oNode2);
    }
}
```

#### 相关知识点

- contains API

  > 查看dom元素包含关系，包含返回true，不包含返回false
  > [参考MDN](https://developer.mozilla.org/zh-CN/docs/Web/API/Node/contains)

- 递归(参考数据结构树)

### 4. [根据包名，在指定空间中创建对象](https://www.nowcoder.com/practice/a82e035501504cedbe881d08c824a381)

#### 问题描述

> 根据包名，在指定空间中创建对象
> 输入描述:
> namespace({a: {test: 1, b: 2}}, 'a.b.c.d')
> 输出描述:
> {a: {test: 1, b: {c: {d: {}}}}}

#### 代码

```js
function namespace(oNamespace, sPackage) {
    // 数组
    let arr = sPackage.split('.');
    // 深入的指针
    let pointer = oNamespace;
    // 遍历包
    for (let i = 0; i < arr.length; i++) {
        // 如果为undefined或者不是对象则赋值为空对象
        if (!pointer[arr[i]] || typeof pointer[arr[i]] !== 'object') {
            pointer[arr[i]] = {};
        }
        // 指针深入该对象
        pointer = pointer[arr[i]];
    }
    return oNamespace;
}
```

代码写的更加严谨一点

```js
function namespace(oNamespace, sPackage) {
    // 数组
    let arr = sPackage.split('.');
    // 深入的指针
    let pointer = oNamespace;
    // 遍历包
    for (let i = 0; i < arr.length; i++) {
        // 如果为undefined或者不是对象则赋值为空对象
        if (!pointer.hasOwnProperty(arr[i]) || Object.prototype.toString.call(pointer[arr[i]]) !== '[object Object]') {
            pointer[arr[i]] = {};
        }
        // 指针深入该对象
        pointer = pointer[arr[i]];
    }
    return oNamespace;
}
```

#### 相关知识点

- 判断对象的自身是否有某属性(hasOwnProperty)

- hasOwnProperty / typeof / in / instanceof 的区别

  > - hasOwnProperty 是判断对象自身有没有某属性，不包含原型链的方法。
  > - in 是判断对象在自身和原型链上有没有该方法。
  > - instanceof 是判断对象在原型链上有没有该方法。
  > - typeof 判断操作数的类型，但是null也会判断为"object"

- 准确判断某值的类型

  > Object.prototype.toString.call(123) === "[object Number]"
  > Object.prototype.toString.call('aaa') === "[object String]"
  > Object.prototype.toString.call(true) === "[object Boolean]"
  > Object.prototype.toString.call(undefined) === "[object Undefined]"
  > Object.prototype.toString.call(null) === '[object Null]'
  > Object.prototype.toString.call({}) === '[object Object]'
  > Object.prototype.toString.call([]) === '[object Array]'
  > Object.prototype.toString.call(Math) === "[object Math]"
  > Object.prototype.toString.call(new Date()) === "[object Date]"
  > Object.prototype.toString.call(new RegExp) === "[object RegExp]"

- 递归(对象的嵌套参考数据结构中的树)

### 5. [数组去重](https://www.nowcoder.com/practice/0b5ae9c4a8c546f79e2547c0179bfdc2)

#### 问题描述

> 为 Array 对象添加一个去除重复项的方法
> 输入
> [false, true, undefined, null, NaN, 0, 1, {}, {}, 'a', 'a', NaN]
> 输出
> [false, true, undefined, null, NaN, 0, 1, {}, {}, 'a']

这个题，狗就狗在，还有NaN，所以要参考[数组去重](https://hxy1997.xyz/2021/02/10/js%E5%87%BD%E6%95%B0%E6%89%8B%E5%86%99/#12-%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D)中的



```
// 方法一：终极思路
Array.prototype.uniq = function () {
    return [...new Set(this)]
}

// 方法二：普通思路，遍历之后比较值
Array.prototype.uniq = function () {
    let arr = []
    let flag = true
    this.forEach(value => {
        // == -1 有两种情况，一种是NaN，一种是有相同值
        if(arr.indexOf(value) === -1) {
            // 如果是NaN
            if(value !== value) {
                // flag是标记，第一个NaN就进，之后的就不进去
                if(flag){
                  arr.push(value)  
                  flag = false
                }
            } else {
                arr.push(value)  
            }
        }
    })
    return arr
}
```

#### 相关知识点

- uniq方法中的this指向哪里?

  > Array构造函数的原型方法中的this指的是数组实例。

- Set的特性

  > Set存储的成员是唯一的，不是重复的，如果有重复会自动过滤掉.
  > [ES6（七）—— Set & Map](https://www.jianshu.com/p/c36684658aba)

- (NaN === NaN) => false

  > NaN ： is not a number，不等于自己
  > typeof NaN => number
  > Object.prototype.toString.call(NaN) => "[object Number]"
  > ES6 新增方法：Number.isNaN() 用来判断是否属于数字

### 6. [斐波那契数列](https://www.nowcoder.com/practice/aa8ffe28ec7c4050b2aa8bc9d26710e9?tpId=2&tqId=10856&rp=1&ru=%2Fta%2Ffront-end&qru=%2Fta%2Ffront-end%2Fquestion-ranking&tab=answerKey)

> 用 JavaScript 实现斐波那契数列函数,返回第n个斐波那契数。 f(1) = 1, f(2) = 1 等

斐波那契数列基本学js都会，1 1 2 3 5 8 13，后一个是前两个的和。

```
// 方法一：递归思路
function fibonacci(n) {
    if(n === 0) return 0
    if(n === 1 || n === 2) return 1
    return fibonacci(n-1) + fibonacci(n-2)
}

// 方法二：迭代思路
function fibonacci(n) {
    let num1 = 1
    let num2 = 1
    let sum = 0
    for(let i = 3; i <= n; i++) {
        sum = num1 + num2
        num1 = num2
        num2 = sum
    }
    return sum
}

// 上面写法可以过oj，但是如果数字大点就超级慢，使用缓存很可
// 方法三：递归优化思路
function fibonacci(n,cache = {}) {
    // 有缓存就直接读缓存
    if(n in cache) return cache[n]
    if(n === 1 || n === 2) {
        cache[n] = 1
        return 1
    }
    // 没有缓存算完之后存入缓存
    let temp = fibonacci(n-1, cache) + fibonacci(n-2,cache)
    cache[n] = temp
    return temp
}
```

相关知识点：

- 递归

### 7. [时间格式化输出](https://www.nowcoder.com/practice/a789783e7c984f10a0bf649f6d4e2d59?tpId=2&tqId=10857&rp=1&ru=%2Fta%2Ffront-end&qru=%2Fta%2Ffront-end%2Fquestion-ranking&tab=answerKey)

> 题目描述
> 按所给的时间格式输出指定的时间
> 格式说明
> 对于 2014.09.05 13:14:20
> yyyy: 年份，2014
> yy: 年份，14
> MM: 月份，补满两位，09
> M: 月份, 9
> dd: 日期，补满两位，05
> d: 日期, 5
> HH: 24制小时，补满两位，13
> H: 24制小时，13
> hh: 12制小时，补满两位，01
> h: 12制小时，1
> mm: 分钟，补满两位，14
> m: 分钟，14
> ss: 秒，补满两位，20
> s: 秒，20
> w: 星期，为 ['日', '一', '二', '三', '四', '五', '六'] 中的某一个，本 demo 结果为 五
>
> 输入
> formatDate(new Date(1409894060000), 'yyyy-MM-dd HH:mm:ss 星期w')
>
> 输出
> 2014-09-05 13:14:20 星期五

```
function formatDate(t,str) {
    let year = ''+t.getFullYear()
    let month = t.getMonth() + 1
    let day = t.getDate()
    let hour = t.getHours()
    let minutes = t.getMinutes()
    let second = t.getSeconds()
    let week = ['日','一','二','三','四','五','六']
    let date = {
      'yyyy': year,
      'yy': year.slice(2),
      'MM': ten(month),
      'M': month,
      'dd': ten(day),
      'd': day,
      'HH': ten(hour),
      'H': hour,
      'hh': ten(hour % 12),
      'h': hour % 12,
      'mm': ten(minutes),
      'm': minutes,
      'ss': ten(second),
      's': second,
      'w': week[t.getDay()]
    }
    for(let key in date) { 
      str = str.replace(key,date[key])
    }
    return str
  }

  // 不足10的前面要加0
  let ten = num  => num >= 10 ? num : '0' + num
```

考察知识点：

- 获取年月日周时分秒的系统API
- 格式统一处理
- 字符串替换 (replace)

### 8. [获取字符串的长度](https://www.nowcoder.com/practice/e436bbc408744b73b69a8925fac26efc?tpId=2&tqId=10858&rp=1&ru=%2Fta%2Ffront-end&qru=%2Fta%2Ffront-end%2Fquestion-ranking&tab=answerKey)

> 题目描述
> 如果第二个参数 bUnicode255For1 === true，则所有字符长度为 1
> 否则如果字符 Unicode 编码 > 255 则长度为 2
> 输入
> hello world, 牛客', false
> 输出 17

```
function strLength(s, bUnicode255For1) {
    if(bUnicode255For1) return s.length;
    let len = s.length
    for(let i = 0; i < s.length; i++) {
        if(s[i].charCodeAt() > 255) len++
    }
    return len
}
```

相关知识点：

- 获取字符的 Unicode 编码 API —— str.charCodeAt()

### 9. [邮箱字符串判断](https://www.nowcoder.com/practice/c72b2b5472704d4a98597cb74b0257a7?tpId=2&tqId=10859&rp=1&ru=%2Fta%2Ffront-end&qru=%2Fta%2Ffront-end%2Fquestion-ranking&tab=answerKey)

> 题目描述
> 判断输入是否是正确的邮箱格式

考察正则的一道题目，方法也是多种多样，这里只有一种简单的参考。

```
// ^ 表示开头
// [] 表示匹配字符的范围
// \w 表示正常符号 [0-9a-zA-Z_]
// \. 是对任意符.进行转义，表示字符.
// + 表示前面的表达式，一次到多次
function isAvailableEmail(sEmail) {
    return /^[\w\.]+@\w+\.\w+/.test(sEmail)
}
```

相关知识点：

- 邮箱格式
- 正则表达式的规则和匹配

### 10. [颜色字符串转换](https://www.nowcoder.com/practice/80b08802a833419f9c4ccc6e042c1cca?tpId=2&tqId=10860&rp=1&ru=%2Fta%2Ffront-end&qru=%2Fta%2Ffront-end%2Fquestion-ranking&tab=answerKey)

> 题目描述
> 将 rgb 颜色字符串转换为十六进制的形式，如 rgb(255, 255, 255) 转为 #ffffff
>
> 1. rgb 中每个 , 后面的空格数量不固定
> 2. 十六进制表达式使用六位小写字母
> 3. 如果输入不符合 rgb 格式，返回原始输入
>
> 输入 ：'rgb(255, 255, 255)'
> 输出 ：`#ffffff`

```
function rgb2hex(sRGB) {
    // 正则匹配获取三个数值
    let reg = sRGB.match(/^rgb\((\d+),\s*(\d+),\s*(\d+)\)/)
    if(!reg) return sRGB;
    // 字符串拼接
    let str = '#'
    for(let i = 1; i < reg.length; i++) {
      // 将字符串转成数字
      let m = parseInt(reg[i])
      if (m >= 0 && m <= 255) {
        // 然后转化成16进制
        str += (m >= 16 ? m.toString(16) : '0' + m.toString(16))
      } else {
        return sRGB
      }
    }
    return str
  }
```

相关知识点：

- toString的进制转换

  > 颜色是16进制，所以toString(16)可以得到结果

- 字符串中如何截取数字(不限于正则)

**注意：一定要理解之后去程序里面运行一遍。**

### 11. 将字符串转换为驼峰格式

> 题目描述
>  css 中经常有类似 background-image 这种通过 - 连接的字符，通过 javascript 设置样式的时候需要将这种样式转换成 backgroundImage 驼峰格式，请完成此转换功能
>
> 1. 以 - 为分隔符，将第二个起的非空单词首字母转为大写
> 2. -webkit-border-image 转换后的结果为 webkitBorderImage
>     输入 ： 'font-size'
>     输出 ： fontSize



```js
function cssStyle2DomStyle(sName) {
    let arr = sName.split('-')
    for(let i = (arr[0] ? 1 : 2); i < arr.length; i++) {
        arr[i] = arr[i].slice(0,1).toUpperCase()+arr[i].slice(1)
    }
    return arr.join('')
}
```

相关知识点：

- 数组常用方法
  - split/join
  - toUpperCase() —— toUpperCase将小写字符转成大写，toLowerCase将大写字符转成小写
  - slice

### 12. 字符串字符统计

> 题目描述
>  统计字符串中每个字符的出现频率，返回一个 Object，key 为统计字符，value 为出现频率
>
> 1. 不限制 key 的顺序
> 2. 输入的字符串参数不会为空
> 3. 忽略空白字
>
> 输入 : 'hello world'
>  输出 ：{h: 1, e: 1, l: 3, o: 2, w: 1, r: 1, d: 1}



```js
function count(str) {
    let obj = {}
    for (let i = 0; i < str.length; i++) {
        // 去掉空白字符
        if(str[i] !== ' ') {
            // 如果有该属性就+1，没有就设置值为1
            obj[str[i]] = obj.hasOwnProperty(str[i]) ? obj[str[i]] + 1 : 1
        }
    }
    return obj
}
```

相关知识点：

- 对象赋值

### 13. 加粗文字

> 题目描述
>  使用一个标签将“牛客网”三个字加粗显示



```html
<!--方法一：html-->
<p><strong>牛客网</strong>，程序员必备求职神器</p>

<!--方法二：js-->
let p = document.getElementByTagName('p')
let text = p.innterHTML
p.innterHTML = text.replace('牛客网','<strong>牛客网</strong>')
```

相关知识点：

- 获取元素及元素内容
- 加粗标签

### 14. 段落标识

> 题目描述
>  请将下面这句话以段落的形式展示在浏览器中——“牛客网是一个专注于程序员的学习和成长的专业平台。”



```html
<!--方法一：html-->
<p>牛客网是一个专注于程序员的学习和成长的专业平台。</p>

<!--方法二：js-->
let p = document.createElement('p')
p.innerHTML = '牛客网是一个专注于程序员的学习和成长的专业平台。'
document.querySelector('body').append(p)
```

相关知识点：

- 创建标签createElement
- 将元素添加到body中 append()

### 15. 设置文字颜色

> 题目描述
>  请使用嵌入样式将所有p标签设置为红色文字



```html
<!--方法一：行内样式-->
<p style="color:red;">欢迎来到牛客网</p>
<p style="color:red;">在这里，我们为你提供了IT名企的笔试面试题库</p>
<p style="color:red;">在这里，我们以题会友</p>
<p style="color:red;">QQ群号：272820159</p>
<!--方法二：css样式-->
<style>
    p {
        color: red;
    }
</style>
<p>欢迎来到牛客网</p>
<p>在这里，我们为你提供了IT名企的笔试面试题库</p>
<p>在这里，我们以题会友</p>
<p>QQ群号：272820159</p>

<!--方法一：js-->
let p = document.querySelectorAll('p')
for(let i = 0; i < p.length; i++) {
    p[i].style.color = 'red'
}
```

相关知识点:

- 获取所有p元素：querySelectorAll
- 给元素设置style样式：dom.style.color

### 16. 查找数组元素位置

> 题目描述
>  找出元素 item 在给定数组 arr 中的位置
>  输出描述:
>  如果数组中存在 item，则返回元素在数组中的位置，否则返回 -1
>  输入：[ 1, 2, 3, 4 ], 3
>  输出：2



```js
// 方法一：简单遍历
function indexOf(arr, item) {
    for(let i = 0; i < arr.length; i++) {
        if(arr[i] === item) return i
    }
    return -1
}

// 方法二： ES6新增数组方法
function indexOf(arr, item) {
    return arr.findIndex(val => val === item)
}
```

相关知识点：

- 数组遍历
- 函数返回值

### 17. 数组求和

> 题目描述
>  计算给定数组 arr 中所有元素的总和
>  输入描述:
>  数组中的元素均为 Number 类型
>  输入 ： [ 1, 2, 3, 4 ]
>  输出 ： 10



```js
// 方法一：简单方法，普通for循环这里不多加介绍
function sum(arr) {
    let count = 0
    arr.forEach((value, index) => {
        count+=value
    })
    return count
}

// 方法二：reduce
function sum(arr) {
    return arr.reduce((prev, item) => item + prev,0)
}
```

相关知识点：

- 数组遍历
- reduce

### 18. 移除数组中的元素

> 题目描述
>  移除数组 arr 中的所有值与 item 相等的元素。不要直接修改数组 arr，结果返回新的数组
>  输入 : [1, 2, 3, 4, 2], 2
>  输出 : [1, 3, 4]



```js
// 方法一：简单遍历
function remove(arr, item) {
    let newArr = []
    arr.forEach(value =>{
        if(value !== item) newArr.push(value)
    })
    return newArr
}

// 方法二：filter过滤方法
function remove(arr, item) {
    return arr.filter(val => val !== item)
}

// 方法三：新数组中使用splice删除
function remove(arr, item) {
    let newArr = arr.slice(0)
    for(let i = newArr.length - 1; i >= 0 ; i--) {
        if(newArr[i] === item) newArr.splice(i, 1)
    }
    return newArr
}
```

相关知识点：

- 数组方法哪些是在原数组中改的，哪些是返回新数组的?

> 返回新数组的API
>  slice \ map \ filter \ reduce \ concat ...
>  返回原数组的API
>  push \ unshift \ shift \ pop \ splice \ sort \ reverse ...

### 19. 移除数组中的元素

> 题目描述
>  移除数组 arr 中的所有值与 item 相等的元素，直接在给定的 arr 数组上进行操作，并将结果返回
>  输入: [1, 2, 2, 3, 4, 2, 2], 2
>  输出: [1, 3, 4]



```js
// 倒着遍历不用考虑数组长度
function removeWithoutCopy(arr, item) {
    for(let i = arr.length - 1; i >= 0; i--) {
        if(item === arr[i]) arr.splice(i,1)
    }
    return arr
}
```

相关知识点：

- 遍历 + 修改数组长度

### 20. 添加元素

> 题目描述
>  在数组 arr 末尾添加元素 item。不要直接修改数组 arr，结果返回新的数组
>  输入: [1, 2, 3, 4],  10
>  输出: [1, 2, 3, 4, 10]



```js
// 方法一：简单迭代
function append(arr, item) {
    let newArr = []
    arr.forEach(val => newArr.push(val))
    newArr.push(item)
    return newArr
}

// 方法二：slice
function append(arr, item) {
    let arr1 = arr.slice(0)
    arr1.push(item)
    return arr1
}

/// 方法三：concat
function append(arr, item) {
    return arr.concat(item)
}
```

相关知识点：

- 合并新元素，返回新数组

这次好多的方法都是数组方法，所以一定要非常的熟悉。这里再把数组的方法整理放上来。
 [Javascript常用的数组方法](https://www.jianshu.com/p/753e9c5a940e)

### 21. 删除数组最后一个元素

> 题目描述
>  删除数组 arr 最后一个元素。不要直接修改数组 arr，结果返回新的数组
>  输入：[1, 2, 3, 4]
>  输出：[1, 2, 3]

其他简单方法就不写了



```js
// 最常用的方法
function truncate(arr) {
    return arr.slice(0,-1)
}

// 方法二：返回新数组API + pop()
function truncate(arr) {
    let newArr = [].concat(arr)
    newArr.pop()
    return newArr
}
```

相关知识点：

- 数组API

### 22. 添加元素

> 题目描述
>  在数组 arr 开头添加元素 item。不要直接修改数组 arr，结果返回新的数组
>  输入：[1, 2, 3, 4], 10
>  输出：[10, 1, 2, 3, 4]



```js
// 方法一：先把最后一个放进去，然后遍历数组
function prepend(arr, item) {
    let newArr = [item]
    for(let i = 0; i < arr.length ; i++) {
        newArr.push(arr[i])
    }
    return newArr
}

// 方法二：copy新数组，把item添加到第一个
function prepend(arr, item) {
    let arr1 = arr.slice(0)
    arr1.splice(0, 0, item) // arr1.unshift(item)
    return arr1
}

// 方法三：直接使用concat返回新数组
function prepend(arr, item) {
    return [item].concat(arr)
}
```

相关知识点：

- 数组API

### 23. 删除数组第一个元素

> 题目描述
>  删除数组 arr 第一个元素。不要直接修改数组 arr，结果返回新的数组
>  输入：[1, 2, 3, 4]
>  输出：[2, 3, 4]



```js
// 方法一： for循环push元素
function curtail(arr) {
    let newArr = []
    for(let i = 1; i < arr.length ; i++) {
        newArr.push(arr[i])
    }
    return newArr
}

// 方法二：copy原数组，删除元素返回
function curtail(arr) {
    let newArr = arr.slice(0)
    newArr.shift()
    return newArr
}

// 方法三：直接slice截取返回新数组
function curtail(arr) {
    return arr.slice(1)
}
```

相关知识点：

- 数组方法API

### 24. 数组合并

> 题目描述
>  合并数组 arr1 和数组 arr2。不要直接修改数组 arr，结果返回新的数组
>  输入：[1, 2, 3, 4], ['a', 'b', 'c', 1]
>  输出：[1, 2, 3, 4, 'a', 'b', 'c', 1]



```js
// 方法一： 迭代
function concat(arr1, arr2) {
    var newArr=arr1.slice(0);
    for(var i=0;i<arr2.length;i++){
        newArr.push(arr2[i]);
    }
    return newArr;
}

// 方法二：数组合并
function concat(arr1, arr2) {
    return arr1.concat(arr2)
}
```

相关知识点：

- 数组API

### 25. 添加元素

> 题目描述
>  在数组 arr 的 index 处添加元素 item。不要直接修改数组 arr，结果返回新的数组
>  输入：[1, 2, 3, 4], 'z', 2
>  输出：[1, 2, 'z', 3, 4]



```js
// 方法一：普通迭代
function insert(arr, item, index) {
    let newArr = []
    for(let i = 0;i < arr.length; i++) {
        if(i === index) {
            newArr.push(item)
            newArr.push(arr[i])
        } else {
            newArr.push(arr[i])
        }
    }
    return newArr
}

// 方法二：新数组+splice方法
function insert(arr, item, index) {
    let newArr = arr.slice(0)
    newArr.splice(index,0,item)
    return newArr
}

// 方法三：拼数组
function insert(arr, item, index) {
    // 根据index分成两个数组然后concat拼接
    return arr.slice(0,index).concat(item,arr.slice(index))
}
```

相关知识点：

- 数组API

### 26. 计数

> 题目描述
>  统计数组 arr 中值等于 item 的元素出现的次数
>  输入：[1, 2, 4, 4, 3, 4, 3], 4
>  输出：3



```js
// 方法一：计数器
function count(arr, item) {
    let count = 0
    arr.forEach((value,index) => {
        if(value === item) count++
    })
    return count
}

// 方法二：filter过滤了等于item的，最后返回数组长度
function count(arr, item) {
    let newArr = arr.filter(val => val === item)
    return newArr.length
}

// 方法二：reduce
function count(arr, item) {
  return arr.reduce((prev, val) => {
    return val === item ? ++prev : prev
  }, 0)
}
```

相关知识点：

- 数组API

### 27. 查找重复元素

> 题目描述
>  找出数组 arr 中重复出现过的元素
>  输入：[1, 2, 4, 4, 3, 3, 1, 5, 3]
>  输出：[1, 3, 4]



```js
// 方法一：数组排序，双指针如果相邻的相等就放到结果数组中
function duplicates(arr) {
    if(arr.length < 2) return arr
    let newArr = arr.slice(0).sort()
    let result = []
    let i = 0
    let j = 1
    while(j < newArr.length) {
        if(newArr[i] === newArr[j]){
            if(!result.includes(newArr[i])) result.push(newArr[i])
        } else {
            i = j
        }
        j++
    }
    return result
}

// 方法二：使用map记录count，把大于1的输出
function duplicates(arr) {
    let map = new Map()
    arr.forEach(value => {
        if (map.has(value)) {
          let count = map.get(value)
          map.set(value,++count)
        } else {
          map.set(value,1)
        }
    })
    let arr1 = []
    for(let [key,index] of map) {
      if(map.get(key) > 1) arr1.push(key)
    }
    return arr1
}

// 方法三：只有一个的概念就是第一次出现的索引和第二次出现的索引不同
function duplicates(arr) {
    let newArr = []
    arr.forEach((value, index) => {
        if(arr.indexOf(value) !== arr.lastIndexOf(value) && newArr.indexOf(value) === -1) newArr.push(value)
    })
    return newArr
}
```

相关知识点：

- 算法题：双指针
- 计数器
- 索引

### 28. 求二次方

> 题目描述
>  为数组 arr 中的每个元素求二次方。不要直接修改数组 arr，结果返回新的数组
>  输入：[1, 2, 3, 4]
>  输出：[1, 4, 9, 16]

题设，就是为map准备的，牛客不太支持ES6以上的语法，目前不支持 ** ，不过正常是可以用的。



```js
// 方法一：map
function square(arr) {
    // 平方可以 Math.pow(value, 2)  ，也可以 value ** 2
    return arr.map(value => value * value)
}

// 方法二：forEach：如何用forEach实现map，就这么写
function square(arr) {
    let newArr = []
    arr.forEach((value, item) => {
        newArr.push(value * value)
    })
    return newArr
}
```

相关知识点：

- 数组map方法，以及map的方法实现
- 平方的写法

### 29. 查找元素位置

> 题目描述
>  在数组 arr 中，查找值与 item 相等的元素出现的所有位置
>  输入：['a','b','c','d','e','f','a','b','c'] 'a'
>  输出：[0, 6]



```js
// 方法一：forEach，其他的遍历都大同小异，一定是要遍历就对了。
function findAllOccurrences(arr, target) {
    let newArr = []
    arr.forEach((value,index) => {
        if(target === value) newArr.push(index)
    })
    return arr1
}
```

相关知识点：

- 数组API

### 30. 避免全局变量

> 题目描述
>  给定的 js 代码中存在全局变量，请修复
>
> 
>
> ```js
> function globals() {
>     myObject = {
>       name : 'Jory'
>     };
> 
>     return myObject;
> }
> ```



```js
// 方法一： myObject前面加var/let/const都可以
function globals() {
    const myObject = {
      name : 'Jory'
    };

    return myObject;
}
```

相关知识点：

- 作用域

> 不加声明的是全局变量，容易引起全局污染。作用域分为全局作用域、函数作用域，ES6新增了块级作用域。

### 31. 正确的函数定义

> 题目描述
>  请修复给定的 js 代码中，函数定义存在的问题
>  输入：true
>  输出：a
>
> 
>
> ```js
> function functions(flag) {
>     if (flag) {
>       function getValue() { return 'a'; }
>     } else {
>       function getValue() { return 'b'; }
>     }
>     return getValue();
> }
> ```



```js
// 方法一：使用函数表达式
function functions(flag) {
    if (flag) {
      var getValue = ()  => { return 'a'; }
    } else {
      var getValue = () => { return 'b'; }
    }
 
    return getValue();
}

// 上面的等同于下面的，变量提升
function functions(flag) {
    var getValue
    if (flag) {
      getValue = () => { return 'a'; }
    } else {
      getValue = () => { return 'b'; }
    }

    return getValue();
}
```

相关知识点：

- 函数的定义方式

> 函数声明式：函数声明在函数没有执行之前就已经在作用域中会提升，同名的声明会进行覆盖，以下面的为准，那么程序执行的时候一直输出的就是b。
>
> 函数表达式：使用函数表达式，还是会进行变量的提升，只不过这次提升的是变量getValue，在执行的时候，才会根据if语句的流程控制执行不同的函数。

### 31. 正确的使用 parseInt

> 题目描述
>  修改 js 代码中 parseInt 的调用方式，使之通过全部测试用例
>  输入：'12'    输出：12
>  输入： '12px'    输出：12
>  输入： '0x12'    输出：0



```js
// 方法，确定是10进制
function parse2Int(num) {
    return parseInt(num,10);
}
```

相关知识点：

- parseInt

> parseInt经常用于强制类型转换中显式转换成数字，接收两个参数，返回数值或者NaN
>
> parseInt(string, radix)
>  第一个参数是字符串，必须传的。
>  第二个参数是数字的基数，2-36，如果不传或者传0都是以10位基数来计算，如果小于2(不等于0)或者大于36一律返回NaN，如果'0x'开头为16进制，'0'开头不包括0是8进制。
>
> parseInt强制类型转化的时候，如果第一位不是数字就会返回NaN，如果第一位是数字，那么会把后面是数字的返回，不是数字的过滤掉。如果是小数的话，会向下取整成整数。

### 33. 完全等同

> 题目描述
>  判断 val1 和 val2 是否完全等同



```js
function identity(val1, val2) {
     return val1 === val2
}
```

相关知识点：

- 等同

> == 和 === 的区别，简单来说在于，== 只判断值相同，遇到问题，=== 还要判断类型是否相同。
>  这里其实我觉得还需要考虑NaN的问题，NaN !== NaN

### 31. 正确的函数定义

> 题目描述
>  实现一个打点计时器，要求
>
> 1. 从 start 到 end（包含 start 和 end），每隔 100 毫秒 console.log 一个数字，每次数字增幅为 1
> 2. 返回的对象中需要包含一个 cancel 方法，用于停止定时操作
> 3. 第一个数需要立即输出



```js
function count(start, end) {
    // 第一个立即输出
    console.log(start++)
    let time = setInterval(function () {
        if(start >= end) clearInterval(time)
        console.log(start++)
    },100)
    return {
        // 返回的方法是一个函数
        cancel: function () {
            clearInterval(time)
        }
    }
}
```

相关知识点：

- setInterval

> 计时器，如果第一个要立即输出，那么需要手动写一次。
>  定义的时候接收两个参数，第一个是每次执行的函数，第二个是执行时间间隔。
>  返回值接收计时器名称，可以用于清空计时器用。

- 闭包

### 31. 流程控制

> 题目描述
>  实现 fizzBuzz 函数，参数 num 与返回值的关系如下：
>  1、如果 num 能同时被 3 和 5 整除，返回字符串 fizzbuzz
>  2、如果 num 能被 3 整除，返回字符串 fizz
>  3、如果 num 能被 5 整除，返回字符串 buzz
>  4、如果参数为空或者不是 Number 类型，返回 false
>  5、其余情况，返回参数 num
>  输入： 15 ; 输出： fizzbuzz



```js
function fizzBuzz(num) {
    // 如果num为空或者不传，isNaN都为true
    if(isNaN(num)) return false
    if(num % 3 === 0 && num % 5 === 0) {
        return 'fizzbuzz'
    } else if (num % 3 === 0) {
        return 'fizz'
    } else if (num % 5 === 0) {
        return 'buzz'
    } else {
        return num
    }
}
```

相关知识点：

- 流程控制：if-else
- isNaN

> isNaN()，遇到不是Number类型的判断都用这个函数，如果参数不是数字就返回true，其他的判断我觉得都不是这个题要考的。ES6之后新增了方法Number.isNaN() 判断是否是NaN

- 取余 %

### 36. 函数传参

> 题目描述
>  将数组 arr 中的元素作为调用函数 fn 的参数
>  输入：
>  function (greeting, name, punctuation) {return greeting + ', ' + name + (punctuation || '!');}, ['Hello', 'Ellie', '!']
>  输出：
>  Hello, Ellie!



```js
// 方法一：量身定做，传的是数组
function argsAsArray(fn, arr) {
    return fn.apply(this,arr)
}

// 方法二：如果用call就需要使用扩展符打散
function argsAsArray(fn, arr) {
    return fn.call(this,...arr)
}

// 方法三：如果bind处理
function argsAsArray(fn, arr) {
    return fn.bind(this,...arr)()
}
```

相关知识点：

- apply/call/bind (详情见一的第一题)
- fn传参问题

### 37. 函数的上下文

> 题目描述
>  将函数 fn 的执行上下文改为 obj 对象
>  输入：
>  function () {return this.greeting + ', ' + this.name + '!!!';}, {greeting: 'Hello', name: 'Rebecca'}
>  输出：Hello, Rebecca!!!



```js
// 方法一：apply
function speak(fn, obj) {
    return fn.apply(obj)
}

// 方法一：call
function speak(fn, obj) {
    return fn.call(obj)
}

// 方法一：bind
function speak(fn, obj) {
    return fn.bind(obj)()
}
```

相关知识点：

- this指向

> apply/call/bind 都可以修改执行上下文，如果直接调用fn，this指的是window，如果用 apply/call/bind 可以将this改成对象obj

### 38. 返回函数

> 题目描述
>  实现函数 functionFunction，调用之后满足如下条件：
>  1、返回值为一个函数 f
>  2、调用返回的函数 f，返回值为按照调用顺序的参数拼接，拼接字符为英文逗号加一个空格，即 ', '
>  3、所有函数的参数数量为 1，且均为 String 类型
>  输入：
>  functionFunction('Hello')('world')
>  输出： Hello, world



```js
function functionFunction(str) {
    return function f(...arg) {
        // 记得逗号之后要加一个空格，才能过oj
        return str + ', '+arg
    }
}
```

相关知识点：

- 闭包 + 柯里化

> 闭包的作用是一个函数可以访问另一个函数作用域的变量。

### 39. 使用闭包

> 题目描述
>  实现函数 makeClosures，调用之后满足如下条件：
>  1、返回一个函数数组 result，长度与 arr 相同
>  2、运行 result 中第 i 个函数，即 `result[i]()`，结果与 `fn(arr[i])` 相同
>  输入：
>
> 
>
> ```js
> [1, 2, 3], function (x) { 
>   return x * x; 
> }
> ```
>
> 输出：4



```js
// 闭包
function makeClosures(arr, fn) {
    let result = []
    for(let i = 0; i < arr.length; i++) {
        result.push(function(){
          return fn(arr[i])  
        })
    }
    return result
}
```

相关知识点：

- 闭包

> 上面的题，如果不用闭包，那么for循环的嘶吼，最后调用函数的时候，i都是arr.length,如果使用闭包，可以是当时循环的i值。

### 40. 二次封装函数

> 题目描述
>  已知函数 fn 执行需要 3 个参数。请实现函数 partial，调用之后满足如下条件：
>  1、返回一个函数 result，该函数接受一个参数
>  2、执行 result(str3) ，返回的结果与 fn(str1, str2, str3) 一致
>  输入：
>  `var sayIt = function(greeting, name, punctuation) { return greeting + ', ' + name + (punctuation || '!'); }; partial(sayIt, 'Hello', 'Ellie')('!!!');`
>
> 输出：Hello, Ellie!!!



```js
// 方法一：直接调用，因为没有涉及到this，这里直接用arguments来获取，因为arguments是类数组
function partial(fn, str1, str2) {
    return function result() {
        return fn(str1,str2,arguments[0])
    }
}

// 方法二：用扩展运算符拿到参数传入，更加的通用
function partial(fn, str1, str2) {
    return function result(...arg) {
        return fn(str1,str2,arg)
    }
}

// 方法二：ES6箭头函数，this指的是undefined
const partial = (fn, str1, str2) => str3 => fn(str1, str2, str3)
```

相关知识点：

- 闭包
- 获取函数参数arguments

> arguments 类数组，
>  获取长度arguments.length
>  获取元素用数组下标arguments[0]
>  获取当前执行的函数 arguments.callee (ES5严格模式下禁用)

### 41. 使用 arguments

> 题目描述
>  函数 useArguments 可以接收 1 个及以上的参数。请实现函数 useArguments，返回所有调用参数相加后的结果。本题的测试参数全部为 Number 类型，不需考虑参数转换。
>  输入：1, 2, 3, 4
>  输出：10



```js
// 方法一：直接遍历
function useArguments() {
    let count = 0
    for(let i = 0; i < arguments.length; i++) {
        count+= arguments[i]
    }
    return count
}

// 方法二：ES6，把arguments转化成数组用数组的方式相加
function useArguments() {
    return Array.from(arguments).reduce((prev, item) => prev + item, 0)
}
```

相关知识点：

- arguments —— 函数参数的获取和类数组的运算。

### 42. 使用 apply 调用函数

> 题目描述
>  实现函数 callIt，调用之后满足如下条件
>  1、返回的结果为调用 fn 之后的结果
>  2、fn 的调用参数为 callIt 的第一个参数之后的全部参数
>  输入：无    输出：无



```js
// 方法一：把参数从第一个开始截取，然后调用apply
function callIt(fn) {
    let newArr = Array.from(arguments).slice(1)
    return fn.apply(this,newArr)
}
```

相关知识点：

- apply/arguments

### 43. 二次封装函数

> 题目描述
>  实现函数 partialUsingArguments，调用之后满足如下条件：
>  1、返回一个函数 result
>  2、调用 result 之后，返回的结果与调用函数 fn 的结果一致
>  3、fn 的调用参数为 partialUsingArguments 的第一个参数之后的全部参数以及 result 的调用参数
>  输入： 无  输出：无



```js
// 方法一：用call直接扩展运算符
function partialUsingArguments(fn) {
    let args = [].slice.call(arguments,1)
    return function result(...newArgs) {
        return fn.call(this,...args,...newArgs)
    }
}

// 方法二：用apply接收数组
function partialUsingArguments(fn) {
    let args = [].slice.call(arguments,1)
    return function result(...newArgs) {
        return fn.apply(this,args.concat(newArgs))
    }
}

// 方法三：bind
function partialUsingArguments(fn) {
    let args = [].slice.call(arguments,1)
    return function result(...newArgs) {
        return fn.bind(this,...args,...newArgs)()
    }
}
```

相关知识点：

- arguments/apply/call/bind

### 44. 柯里化

> 题目描述
>  已知 fn 为一个预定义函数，实现函数 curryIt，调用之后满足如下条件：
>  1、返回一个函数 a，a 的 length 属性值为 1（即显式声明 a 接收一个参数）
>  2、调用 a 之后，返回一个函数 b, b 的 length 属性值为 1
>  3、调用 b 之后，返回一个函数 c, c 的 length 属性值为 1
>  4、调用 c 之后，返回的结果与调用 fn 的返回值一致
>  5、fn 的参数依次为函数 a, b, c 的调用参数
>  输入
>  `var fn = function (a, b, c) {return a + b + c}; curryIt(fn)(1)(2)(3);`  
>  输出 6



```js
function curryIt(fn) {
    let len = fn.length
    let args = []
    return function (arg){
        args.push(arg)
        if(len > args.length) {
            return arguments.callee
        }
        return fn.apply(this, args)
    }
}
```

相关知识点：

- 柯里化

> [函数式编程（三）—— 柯里化](https://links.jianshu.com/go?to=https%3A%2F%2Fjuejin.cn%2Fpost%2F6863422127899590663)

- 函数形参长度获取：fn.length

### 45. 或运算

> 题目描述
>  返回参数 a 和 b 的逻辑或运算结果
>  输入： false, true ; 输出： true



```js
// 方法一：直接或运算符
function or(a, b) {
    return a || b
}

// 方法二：位运算中的或运算，返回0或者1，需要转化类型为布尔值
function or(a, b) {
    return a | b ? true : false
}
```

相关知识点：

- 或运算

> || 运算符，a和b都为false，才是false，其中一个有true，就是false
>  | 运算符，是位运算，位置上都是0才返回0，位置上有一个1就返回1，如果返回需要布尔值，需要转化

### 46. 且运算

> 题目描述
>  返回参数 a 和 b 的逻辑且运算结果
>  输入：
>  false, true
>  输出：
>  false



```js
// 方法一：且运算符，返回布尔值
function and(a, b) {
    return a && b
}

// 方法二：位运算的且运算符，返回 0 和 1，需要转化成布尔值
function and(a, b) {
    return a & b ? true : false
}
```

相关知识点：

- 且运算

> && 运算符，a和b都为true，才是true，其中一个有false，就是false
>  & 运算符，是位运算，位置上都是1才返回1，位置上有一个0就返回0，如果返回需要布尔值，需要转化

### 47. 模块

> 题目描述
>  完成函数 createModule，调用之后满足如下要求：
>  1、返回一个对象
>  2、对象的 greeting 属性值等于 str1， name 属性值等于 str2
>  3、对象存在一个 sayIt 方法，该方法返回的字符串为 greeting属性值 + ', ' + name属性值



```js
// 方法一：对象
function createModule(str1, str2) {
    return  {
        greeting: str1,
        name: str2,
        sayIt: function (){
            return this.greeting + ', ' + this.name
        }
    }
}

// 方法二： 构造函数
function createModule(str1, str2) {
    function Obj() {
        this.greeting = str1
        this.name = str2
    }
    Obj.prototype.sayIt = function () {
        return this.greeting + ', ' + this.name
    }
    return new Obj
}
```

相关知识点：

- 模块化、构造函数、对象

### 48. 二进制转换

> 题目描述
>  获取数字 num 二进制形式第 bit 位的值。注意：
>  1、bit 从 1 开始
>  2、返回 0 或 1
>  3、举例：2 的二进制为 10，第 1 位为 0，第 2 位为 1
>  输入： 128，8
>  输出： 1



```js
// 方法一：while循环
function valueAtBit(num, bit) {
    let arr = []
    while(num){
        arr.push(num % 2)
        num = Math.floor(num / 2)
    }
    return arr[bit-1]
}

// 方法二：位运算右移 >> 位数 - 1 然后取模 2
function valueAtBit(num, bit) {
    return (num >> bit - 1) % 2
}
```

相关知识点：

- 二进制数值运算
- 取模
- 位运算符 左移 >> 右移 << 无符号位右移 <<<

### 49. 二进制转换

> 题目描述
>  给定二进制字符串，将其换算成对应的十进制数字
>  输入：'11000000'
>  输出：192



```js
// 方法一：parseInt(str,2) 
// 方法二：
function base10(str) {
    let count = 0
    for(let i = 0; i < str.length; i++) {
        count = count * 2 + str[i]*1
    }
    return count
}
```

相关知识点：

- 进制转换

> 二进制转十进制，从最高位开始乘2，十进制转二进制，除2取余后取逆向

### 50. 二进制转换

> 题目描述
>  将给定数字转换成二进制字符串。如果字符串长度不足 8 位，则在前面补 0 到满8位。
>  输入：65
>  输出：01000001(字符串)



```js
// 方法一：转化之后检查位(算法思维，推荐)
function convertToBinary(num) {
    let arr = []
    while(num) {
        arr.push(num % 2)
        num = num >> 1
    }
    let str = ''
    let len = arr.length > 8 ? arr.length : 8
    for(let i = len - 1; i >= 0; i--){
        str = arr[i] ? str + '1' : str + '0'
    }
    return str
}

// 方法二：使用API转化成二进制然后看缺的(尽量不要前面加字符串，性能消耗大)
function convertToBinary(num) {
    var str = num.toString(2);
    while(str.length < 8) {
        str = "0" + str;
    }
    return str;
}
```

相关知识点：

- 二进制转换

51. 乘法
题目描述
求 a 和 b 相乘的值，a 和 b 可能是小数，需要注意结果的精度问题
输入：3, 0.0001
输出：0.0003

```
// 方法一：确定小数的位数然后保证精度是多少位
function multiply(a, b) {
    let arrA = a.toString().split('.')[1] || ''
    let arrB = b.toString().split('.')[1] || ''
    let fix = arrA.length + arrB.length
    return (a * b).toFixed(fix)
}

// 方法二：自己写的
function multiply(a, b) {
    let arrA = a.toString().split('.')
    let arrB = b.toString().split('.')
    let count = 0
    // 第一个有小数位
    if(arrA[1]) {
        count+=arrA.length
        a = a * Math.pow(10,arrA.length)
    }
    // 第二个数有小数位
    if(arrB[1]) {
        count+=arrB.length
        b = b * Math.pow(10,arrB.length)
    }
    return a * b * Math.pow(10, -count)
}
```


相关知识点：

相关知识点：

javascript小数精度问题
javascript的数值存储是双精度浮点数64位，根据IEEE 754标准，0-51为值，52-62位指数，63位是符号位。
二进制浮点数表示法对0.1这样的有误差。
解决方法就是先升幂再降幂。


52. 改变上下文
题目描述
将函数 fn 的执行上下文改为 obj，返回 fn 执行后的值
输入：
alterContext(function() {return this.greeting + ', ' + this.name + '!'; }, {name: 'Rebecca', greeting: 'Yo' })
输出：Yo, Rebecca!

```js
// 方法一：call
function alterContext(fn, obj) {
    return fn.call(obj)
}

// 方法一：apply
function alterContext(fn, obj) {
    return fn.apply(obj)
}

// 方法一：bind
function alterContext(fn, obj) {
    return fn.bind(obj)()
}
```


相关知识点：

相关知识点：

call/apply/bind
53. 批量改变对象的属性
题目描述
给定一个构造函数 constructor，请完成 alterObjects 方法，将 constructor 的所有实例的 greeting 属性指向给定的 greeting 变量。
输入：

```js
var C = function(name) {this.name = name; return this;};   
var obj1 = new C('Rebecca');   
alterObjects(C, 'What\'s up'); obj1.greeting;  
1
2
3
输出：What’s up

// 方法一：原型对象上添加属性
function alterObjects(constructor, greeting) {
    constructor.prototype.greeting = greeting
}
```


相关知识点：

原型链
54. 属性遍历
题目描述
找出对象 obj 不在原型链上的属性(注意这题测试例子的冒号后面也有一个空格~)
1、返回数组，格式为 key: value
2、结果数组不要求顺序
输入

```js
var C = function() {this.foo = 'bar'; this.baz = 'bim';}; 
C.prototype.bop = 'bip'; 
iterate(new C());
```


输出 ["foo: bar", "baz: bim"]

```js
// 方法一： forEach换成map更好，这里不是重点所以不做处理
function iterate(obj) {
    let arr = []
    Object.getOwnPropertyNames(obj).forEach(value => arr.push(`${value}: ${obj[value]}`))
    return arr
}

```

相关知识点：

Object.getOwnPropertyNames(obj)， 获取所有的对象自身属性


55. 判断是否包含数字
题目描述
给定字符串 str，检查其是否包含数字，包含返回 true，否则返回 false
输入： ‘abc123’ ; 输出： true

```js
// 方法一：字符串比较ASCII码
function containsNumber(str) {
    for (let i = 0; i < str.length; i++) {
        if(str[i] >= '0' && str[i] <= '9') {
            return true
        }
    }
    return false
}

// 方法二：隐式类型转化
function containsNumber(str) {
    for (let i = 0; i < str.length; i++) {
        if(str[i] >= 0 || str[i] <= 9) {
            return true
        }
    }
    return false
}

// 方法三：正则
function containsNumber(str) {
    return /\d/g.test(str)
}
```


相关知识点：

相关知识点：

字符串比较ASCII码
字符串比较会比较他们的ASCII码值，数字是连续的ASCII码，0123456789分别是48-57，在这个范围内的就可以。

隐式类型转化
数字字符串和数字比较，会隐式转化成数字，字符串和数字比较，会转化成数字NaN，和数字比较返回false，所以这种方式也可以找到字符串中是否有数字。

正则


56. 检查重复字符串
题目描述
给定字符串 str，检查其是否包含连续重复的字母（a-zA-Z），包含返回 true，否则返回 false
输入： ‘rattler’
输出： true

```js
// 方法一：双指针
function containsRepeatingLetter(str) {
    // 如果字符串长度小于2直接返回false
    if(str.length < 2)return false
    // 左右指针
    let left = 0
    let right = 1
    while(str[right]) {
        // 如果左右相等且都是a-z范围的就返回true
        if(str[left++] === str[right++] && str[left].toLowerCase() >= 'a' && str[left].toLowerCase() <= 'z' && str[right].toLowerCase() >= 'a' && str[right].toLowerCase() <= 'z'){
            return true
        }
    }
    // 否则返回false
    return false
    
}

// 方法二：正则，小括号表示分组，\1表示引用第一个分组
function containsRepeatingLetter(str) {
    return /([a-zA-Z])\1/.test(str);
}
```


相关知识点：

双指针(算法思维)
正则
57. 判断是否以元音字母结尾
题目描述
给定字符串 str，检查其是否以元音字母结尾
1、元音字母包括 a，e，i，o，u，以及对应的大写
2、包含返回 true，否则返回 false
输入： ‘gorilla’ ; 输出： true

```js
// 方法一：indexOf
function endsWithVowel(str) {
    return ['a','e','i','o','u'].indexOf(str.slice(-1).toLowerCase()) === -1 ? false: true
}

// 方法二：includes
function endsWithVowel(str) {
    return ['a','e','i','o','u'].includes(str.slice(-1).toLowerCase())
}
```


相关知识点：

相关知识点：

字符串方法slice，toLowerCase
数组方法indexOf，includes
58. 获取指定字符串
题目描述
给定字符串 str，检查其是否包含 连续3个数字
1、如果包含，返回最先出现的 3 个数字的字符串
2、如果不包含，返回 false
输入： ‘9876543’
输出： 987

PS: 这个题我们理解的是三个连续递增的数字，但是题的意思是连续的数字即可。

```js
// 方法一：计数器
function captureThreeNumbers(str) {
  let start = 0
  let count = 0
  for(let i = 0; i < str.length; i++) {
    if (!isNaN(str[i])) {
      count++
    } else {
      count = 0
      start = i+1
    }
  }

  return count >= 3 ? str[start]+str[start+1]+str[start+2] : false
}

// 方法二：正则 match可以得到匹配的结果
function captureThreeNumbers(str) {
  let arr = str.match(/\d{3}/)
  return arr ? arr[0] : false
}
```


如果是连续递增的数字，要这样实现：

如果是连续递增的数字，要这样实现：

```js
// 方法一：双指针
function captureThreeNumbers(str) {
    let left = 0
    let right = 0
    while(str[right+1] !== undefined) {
        // 保证右指针连续，且属于数字，右指针往过移动
        if(Math.abs(str[right+1] - str[right]) === 1 && str[right] >=0 && str[right] <=9) {
            right++
        // 如果小于3，左指针就去右指针右边
        }else if(right - left + 1 < 3){
            left = ++right
        // 大于3直接返回    
        }else {
            return str.substr(left,3)
        }
    }
    // 循环结果，如果大于3就返回，否则返回false
    return right - left + 1 >= 3 ? str.substr(left,3) : false
}
```


相关知识点：

计数器
正则
双指针(算法思维) + 判断连续数字
59. 判断是否符合指定格式
题目描述
给定字符串 str，检查其是否符合如下格式
1、XXX-XXX-XXXX
2、其中 X 为 Number 类型
输入：‘800-555-1212’
输出：true

```js
// 方法一：正则
function matchesPattern(str) {
    return /^\d{3}-\d{3}-\d{4}$/.test(str)
}
```

相关知识点：

匹配或者判断什么格式就优先考虑正则
60. 判断是否符合 USD 格式
题目描述
给定字符串 str，检查其是否符合美元书写格式
1、以 $ 开始
2、整数部分，从个位起，满 3 个数字用 , 分隔
3、如果为小数，则小数部分长度为 2
4、正确的格式如：$1,023,032.03 或者 $2.03，
错误的格式如：$3,432,12.12 或者 $34,344.3
输入：'$20,933,209.93'
输出：true

```js
// 方法一：正则，从左往右写，依次匹配
function isUSD(str) {
    return /^\$[\d]{1,3}(\,[\d]{3})*(|\.[\d]{2})$/.test(str)
}
```

相关知识点：

正则
已经到底拉，60道题完事，恭喜你，通关啦~~~~