---
title:  链表刷题
date:  2021-03-09 00:02:39
categories: 
- 刷题
tags:
- javascript
- 数据结构和算法
- 链表
---

按照算法和数据结构进行分类，一起来刷题，用于自己在面试前查漏补缺。我的意向岗位是前端，选择用javascript来刷题，优点是动态语言，语法简单，缺点是遇见复杂数据结构会出现较难的写法，如堆、并查集，每题对应leetcode的题号。本篇是链表
<!-- more -->

## 专题部分

### 链表

#### [2. 两数相加](https://leetcode-cn.com/problems/add-two-numbers/)

给你两个 **非空** 的链表，表示两个非负的整数。它们每位数字都是按照 **逆序** 的方式存储的，并且每个节点只能存储 **一位** 数字。

请你将两个数相加，并以相同形式返回一个表示和的链表。

你可以假设除了数字 0 之外，这两个数都不会以 0 开头。

**示例 1：**

![img](https://cdn.jsdelivr.net/gh/huxingyi1997/my_img/img/20210627203450.jpeg)

```
输入：l1 = [2,4,3], l2 = [5,6,4]
输出：[7,0,8]
解释：342 + 465 = 807.
```

**示例 2：**

```
输入：l1 = [0], l2 = [0]
输出：[0]
```

**示例 3：**

```
输入：l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]
输出：[8,9,9,9,0,0,0,1]
```

 **提示：**

- 每个链表中的节点数在范围 `[1, 100]` 内
- `0 <= Node.val <= 9`
- 题目数据保证列表表示的数字不含前导零

主要是要注意进位和只有一个链表还有一位的情况

```javascript
/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */
/**
 * @param {ListNode} l1
 * @param {ListNode} l2
 * @return {ListNode}
 */
var addTwoNumbers = function(l1, l2) {
    let dummy = new ListNode();
    let pre  = dummy;
    let flag = 0;
    while (l1 || l2 || flag) {
        let x1 = l1 != null ? l1.val: 0;  
        let x2 = l2 != null ? l2.val: 0;  
        flag = x1 + x2 + flag;
        let node = new ListNode(flag % 10);
        pre.next = node;
        pre = pre.next;
        flag = Math.floor(flag / 10);
        l1 && (l1 = l1.next);
        l2 && (l2 = l2.next);
    }
    return dummy.next;
};
```

#### [19. 删除链表的倒数第 N 个结点](https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/)

给你一个链表，删除链表的倒数第 `n` 个结点，并且返回链表的头结点。

**进阶：**你能尝试使用一趟扫描实现吗？

**示例 1：**

![img](https://cdn.jsdelivr.net/gh/huxingyi1997/my_img/img/20210710172618.jpeg)

```
输入：head = [1,2,3,4,5], n = 2
输出：[1,2,3,5]
```

**示例 2：**

```
输入：head = [1], n = 1
输出：[]
```

**示例 3：**

```
输入：head = [1,2], n = 1
输出：[1]
```

**提示：**

- 链表中结点的数目为 `sz`
- `1 <= sz <= 30`
- `0 <= Node.val <= 100`
- `1 <= n <= sz`

快慢指针，找到对应节点的前一个节点，删除该节点

```javascript
/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */
/**
 * @param {ListNode} head
 * @param {number} n
 * @return {ListNode}
 * 双指针
 */
var removeNthFromEnd = function(head, n) {
    let dummy = new ListNode(null);
    dummy.next = head;
    let slow = dummy;
    let fast = dummy;
    for(let i = 0; i <= n; i ++) {
        fast = fast.next;
    }
    while(fast != null) {
        fast = fast.next;
        slow = slow.next;
    }
    slow.next = slow.next.next;
    return dummy.next;
};
```

#### 23.[合并K个升序链表](https://leetcode-cn.com/problems/merge-k-sorted-lists/)

给你一个链表数组，每个链表都已经按升序排列。

请你将所有链表合并到一个升序链表中，返回合并后的链表。

**示例 1：**

```
输入：lists = [[1,4,5],[1,3,4],[2,6]]
输出：[1,1,2,3,4,4,5,6]
解释：链表数组如下：
[
  1->4->5,
  1->3->4,
  2->6
]
将它们合并到一个有序链表中得到。
1->1->2->3->4->4->5->6
```

**示例 2：**

```
输入：lists = []
输出：[]
```

**示例 3：**

```
输入：lists = [[]]
输出：[]
```

**提示：**

- `k == lists.length`
- `0 <= k <= 10^4`
- `0 <= lists[i].length <= 500`
- `-10^4 <= lists[i][j] <= 10^4`
- `lists[i]` 按 **升序** 排列
- `lists[i].length` 的总和不超过 `10^4`

先写出归并2个有序链表的函数，然后归并排序

```javascript
/*
 * function ListNode(x){
 *   this.val = x;
 *   this.next = null;
 * }
 */

/**
 * 
 * @param lists ListNode类一维数组 
 * @return ListNode类
 */
function mergeKLists( lists ) {
    // write code here
    const len = lists.length;
    if (len === 0) return null;
    if (len === 1) return lists[0];
    return mergeTwoLists(mergeKLists(lists.slice(0, len >> 1)), mergeKLists(lists.slice(len >> 1)));
}
function mergeTwoLists( l1 ,  l2 ) {
    // write code here
    if (!l1) return l2;
    if (!l2) return l1;
    // 头指针
    let dummy = new ListNode(0);
    // 当前指针
    let cur = dummy;
    // 两个数组均有数
    while (l1 != null && l2 != null) {
        if (l1.val <= l2.val) {
            cur.next = l1;
            l1 = l1.next;
        } else {
            cur.next = l2;
            l2 = l2.next;
        }
        // 当前指针前进
        cur = cur.next;
    }
    // 将未遍历完的赋值
    cur.next = l1 ? l1 : l2;
    return dummy.next;
}
module.exports = {
    mergeKLists : mergeKLists
};
```

#### 25.[K 个一组翻转链表](https://leetcode-cn.com/problems/reverse-nodes-in-k-group/)

给你一个链表，每 *k* 个节点一组进行翻转，请你返回翻转后的链表。

*k* 是一个正整数，它的值小于或等于链表的长度。

如果节点总数不是 *k* 的整数倍，那么请将最后剩余的节点保持原有顺序。

**进阶：**

- 你可以设计一个只使用常数额外空间的算法来解决此问题吗？
- **你不能只是单纯的改变节点内部的值**，而是需要实际进行节点交换。

**示例 1：**

![img](https://assets.leetcode.com/uploads/2020/10/03/reverse_ex1.jpg)

```
输入：head = [1,2,3,4,5], k = 2
输出：[2,1,4,3,5]
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2020/10/03/reverse_ex2.jpg)

```
输入：head = [1,2,3,4,5], k = 3
输出：[3,2,1,4,5]
```

**示例 3：**

```
输入：head = [1,2,3,4,5], k = 1
输出：[1,2,3,4,5]
```

**示例 4：**

```
输入：head = [1], k = 1
输出：[1]
```

**提示：**

- 列表中节点的数量在范围 `sz` 内
- `1 <= sz <= 5000`
- `0 <= Node.val <= 1000`
- `1 <= k <= sz`

递归操作

```javascript
/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */
/**
 * @param {ListNode} head
 * @param {number} k
 * @return {ListNode}
 */
var reverseKGroup = function (head, k) {
    if (head == null) return head;
    // 区间 [a, b) 包含 k 个待反转元素
    let a = head, b = head;
    for (let i = 0; i < k; i++) {
        // 不足 k 个，不需要反转，base case
        if (b == null) return head;
        b = b.next;
    }
    // 反转前 k 个元素
    let newHead = reverse(a, b);
    // 递归反转后续链表并连接起来
    a.next = reverseKGroup(b, k);
    return newHead;
};

function reverse (head, tail) {
    let pre = null, cur = head, nxt = head;
    while (cur != tail) {
        nxt = cur.next;
        // 逐个结点反转
        cur.next = pre;
        // 更新指针位置
        pre = cur;
        cur = nxt;
    }
    // 返回反转后的头结点
    return pre;
}
```

先统计数量，再K个一组翻转

```javascript
/*
 * function ListNode(x){
 *   this.val = x;
 *   this.next = null;
 * }
 */

/**
  * 
  * @param head ListNode类 
  * @param k int整型 
  * @return ListNode类
  */
function reverseKGroup( head ,  k ) {
    // write code here
    if (!head || !head.next || k < 2) return head;
    let dummy = new ListNode(0);
    dummy.next = head;
    let pre = dummy;
    let cur = head;
    let len = 0;
    while (head) {
        len++;
        head = head.next;
    }
    for (let i = 0; i < Math.floor(len / k); i++) {
        for (let j = 1; j < k; j++) {
            // 翻转之后头结点会变成尾节点，此时指向头结点的下一个节点会成为新的头结点。
            let next = cur.next;
            // 每次翻转一个节点，尾节点指向第三个节点。
            cur.next = next.next;
            // 翻转
            next.next = pre.next;
            // pre.next指向翻转后的头结点
            pre.next = next;
        }
        // 每K个节点的哑节点
        pre = cur;
        // 每K个节点的首节点
        cur = cur.next;
    }
    return dummy.next;
}
module.exports = {
    reverseKGroup : reverseKGroup
};
```

#### [链表内指定空间翻转](https://www.nowcoder.com/practice/b58434e200a648c589ca2063f1faf58c)

题目描述

将一个链表m 位置到 n 位置之间的区间反转，要求时间复杂度 O(n)，空间复杂度 O(1)。
例如：
给出的链表为1→2→3→4→5→NULL, m=2,n=4,
返回 1→4→3→2→5→NULL.
注意：
给出的 m,n 满足以下条件：
1≤m≤n≤链表长度

示例1

输入

```
{1,2,3,4,5},2,4
```

返回值

```
{1,4,3,2,5}
```

找到头部和尾部，进行翻转

```javascript
/*
 * function ListNode(x){
 *   this.val = x;
 *   this.next = null;
 * }
 */

/**
  * 
  * @param head ListNode类 
  * @param m int整型 
  * @param n int整型 
  * @return ListNode类
  */
function reverseBetween( head ,  m ,  n ) {
    // write code here
    let dummy = new ListNode(0);
    dummy.next = head;
    let pre = dummy;
    let cur = head;
    for (let i = 0; i < m - 1; i++) {
        pre = pre.next;
        cur = cur.next;
    }
    for (let j = 0; j < n - m; j++) {
        let temp = cur.next;
        cur.next = temp.next;
        temp.next = pre.next;
        pre.next = temp;
    }
    return dummy.next;
}
module.exports = {
    reverseBetween : reverseBetween
};
```

#### 141.[环形链表](https://leetcode-cn.com/problems/linked-list-cycle/)

给定一个链表，判断链表中是否有环。

如果链表中有某个节点，可以通过连续跟踪 `next` 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们使用整数 `pos` 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 `pos` 是 `-1`，则在该链表中没有环。**注意：`pos` 不作为参数进行传递**，仅仅是为了标识链表的实际情况。

如果链表中存在环，则返回 `true` 。 否则，返回 `false` 。

**进阶：**

你能用 *O(1)*（即，常量）内存解决此问题吗？

**示例 1：**

![img](https://cdn.jsdelivr.net/gh/huxingyi1997/my_img/img/20210710165835.png)

```
输入：head = [3,2,0,-4], pos = 1
输出：true
解释：链表中有一个环，其尾部连接到第二个节点。
```

**示例 2：**



```
输入：head = [1,2], pos = 0
输出：true
解释：链表中有一个环，其尾部连接到第一个节点。
```

**示例 3：**

![img](https://cdn.jsdelivr.net/gh/huxingyi1997/my_img/img/20210419095830.png)

```
输入：head = [1], pos = -1
输出：false
解释：链表中没有环。
```

 **提示：**

- 链表中节点的数目范围是 `[0, 104]`

- `-105 <= Node.val <= 105`

- `pos` 为 `-1` 或者链表中的一个 **有效索引** 。

快慢指针

```javascript
/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */

/**
 * @param {ListNode} head
 * @return {boolean}
 */
var hasCycle = function(head) {
    let fast = head, slow = head;
    while (fast !== null && fast.next !== null) {
        fast = fast.next.next;
        slow = slow.next;
        if (fast == slow) return true;
    }
    return false;
};
```

#### [160. 相交链表](https://leetcode-cn.com/problems/intersection-of-two-linked-lists/)

给你两个单链表的头节点 `headA` 和 `headB` ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 `null` 。

图示两个链表在节点 `c1` 开始相交**：**

![img](https://cdn.jsdelivr.net/gh/huxingyi1997/my_img/img/20210604203701.png)

题目数据 **保证** 整个链式结构中不存在环。

**注意**，函数返回结果后，链表必须 **保持其原始结构** 。

示例 1：

![img](https://cdn.jsdelivr.net/gh/huxingyi1997/my_img/img/20210604204535.png)

```
输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3
输出：Intersected at '8'
解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。
从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。
在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。
```

示例 2：

![img](https://cdn.jsdelivr.net/gh/huxingyi1997/my_img/img/20210604204609.png)

```
输入：intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1
输出：Intersected at '2'
解释：相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。
从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。
在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。
```

示例 3：

![img](https://cdn.jsdelivr.net/gh/huxingyi1997/my_img/img/20210604204716.png)



```
输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2
输出：null
解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。
由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。
这两个链表不相交，因此返回 null 。
```


提示：

listA 中节点数目为 m
listB 中节点数目为 n
0 <= m, n <= 3 * 104
1 <= Node.val <= 105
0 <= skipA <= m
0 <= skipB <= n
如果 listA 和 listB 没有交点，intersectVal 为 0
如果 listA 和 listB 有交点，intersectVal == listA[skipA + 1] == listB[skipB + 1]


进阶：你能否设计一个时间复杂度 O(n) 、仅用 O(1) 内存的解决方案？

使用双指针完成设计

```javascript
/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */

/**
 * @param {ListNode} headA
 * @param {ListNode} headB
 * @return {ListNode}
 */
var getIntersectionNode = function(headA, headB) {
    let pointA = headA, pointB = headB;
    while (pointA !== pointB) {
        pointA = pointA ? pointA.next : headB;
        pointB = pointB ? pointB.next : headA;
    }
    return pointA;
};
```

#### [203. 移除链表元素](https://leetcode-cn.com/problems/remove-linked-list-elements/)

给你一个链表的头节点 `head` 和一个整数 `val` ，请你删除链表中所有满足 `Node.val == val` 的节点，并返回 **新的头节点** 。

**示例 1：**

![img](https://cdn.jsdelivr.net/gh/huxingyi1997/my_img/img/20210605102640.jpeg)

```
输入：head = [1,2,6,3,4,5,6], val = 6
输出：[1,2,3,4,5]
```

**示例 2：**

```
输入：head = [], val = 1
输出：[]
```

**示例 3：**

```
输入：head = [7,7,7,7], val = 7
输出：[]
```

**提示：**

- 列表中的节点在范围 `[0, 104]` 内
- `1 <= Node.val <= 50`
- `0 <= k <= 50`

直接使用哑节点了，很方便

```javascript
/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode} head
 * @param {number} val
 * @return {ListNode}
 */
var removeElements = function(head, val) {
    // 哑节点
    let dummy = new ListNode(0);
    dummy.next = head;
    let cur = dummy;
    while (cur.next !== null) {
        if (cur.next.val === val) {
            cur.next = cur.next.next;
        } else if (cur.next !== null) {
            cur = cur.next;
        }
    }
    return dummy.next;
};
```

#### 328.[奇偶链表](https://leetcode-cn.com/problems/odd-even-linked-list/)

给定一个单链表，把所有的奇数节点和偶数节点分别排在一起。请注意，这里的奇数节点和偶数节点指的是节点编号的奇偶性，而不是节点的值的奇偶性。

请尝试使用原地算法完成。你的算法的空间复杂度应为 O(1)，时间复杂度应为 O(nodes)，nodes 为节点总数。

**示例 1:**

```
输入: 1->2->3->4->5->NULL
输出: 1->3->5->2->4->NULL
```

**示例 2:**

```
输入: 2->1->3->5->6->4->7->NULL 
输出: 2->3->6->7->1->5->4->NULL
```

**说明:**

- 应当保持奇数节点和偶数节点的相对顺序。
- 链表的第一个节点视为奇数节点，第二个节点视为偶数节点，以此类推。

```javascript
/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode} head
 * @return {ListNode}
 */
var oddEvenList = function(head) {
   if (head === null) return head;
    let evenHead = head.next;
    // 奇指针，偶指针
    let odd = head, even = evenHead;
    // 迭代
    while (even !== null && even.next !== null) {
        // 奇指针下个节点指向当前偶节点的下一个指针
        odd.next = even.next;
        // 奇指针前移
        odd = odd.next;
        // 偶指针下个节点指向当前奇节点的下一个指针
        even.next = odd.next;
        // 偶指针前移
        even = even.next;
    }
    // 奇指针末尾节点指向偶指针第一个节点
    odd.next = evenHead;
    return head;
};
```

