---
title:  力扣周赛301-
date:  2022-07-19 18:00:00
categories: 
- 刷题
tags:
- 刷题
- 力扣
- 周赛
---
在今年寒假改完论文后，做了一个决定，就是在条件允许的情况下参加力扣周赛。只是做自己想做的事，语言用回C++吧。希望自己能够在其中得到成长。

<!-- more -->

## [Weekly Contest 301](https://leetcode.com/contest/weekly-contest-301/)

![image-20220710174532073](https://cdn.jsdelivr.net/gh/huxingyi1997/my_img/img/20220710181033.png)



### [2335. Minimum Amount of Time to Fill Cups](https://leetcode.com/problems/minimum-amount-of-time-to-fill-cups/)

You have a water dispenser that can dispense cold, warm, and hot water. Every second, you can either fill up `2` cups with **different** types of water, or `1` cup of any type of water.

You are given a **0-indexed** integer array `amount` of length `3` where `amount[0]`, `amount[1]`, and `amount[2]` denote the number of cold, warm, and hot water cups you need to fill respectively. Return *the **minimum** number of seconds needed to fill up all the cups*.

 

**Example 1:**

```
Input: amount = [1,4,2]
Output: 4
Explanation: One way to fill up the cups is:
Second 1: Fill up a cold cup and a warm cup.
Second 2: Fill up a warm cup and a hot cup.
Second 3: Fill up a warm cup and a hot cup.
Second 4: Fill up a warm cup.
It can be proven that 4 is the minimum number of seconds needed.
```

**Example 2:**

```
Input: amount = [5,4,4]
Output: 7
Explanation: One way to fill up the cups is:
Second 1: Fill up a cold cup, and a hot cup.
Second 2: Fill up a cold cup, and a warm cup.
Second 3: Fill up a cold cup, and a warm cup.
Second 4: Fill up a warm cup, and a hot cup.
Second 5: Fill up a cold cup, and a hot cup.
Second 6: Fill up a cold cup, and a warm cup.
Second 7: Fill up a hot cup.
```

**Example 3:**

```
Input: amount = [5,0,0]
Output: 5
Explanation: Every second, we fill up a cold cup.
```

 

**Constraints:**

- `amount.length == 3`
- `0 <= amount[i] <= 100`

Easy，这题我理了很久才想明白三个数的关系，静下心来，不要被自己的第一想法所左右

```c++
class Solution {
public:
    int fillCups(vector<int>& amount) {
        sort(amount.begin(), amount.end());
        int res = amount[1] - amount[0];
        amount[1] -= res;
        amount[2] -= res;
        // cout<<amount[2]<<endl;
        
        int k = amount[2] / 2, m = amount[2] % 2;
        if (amount[0] < k) {
            return amount[2] + res;
        } else if (amount[0] == k) {
            return res + 2 * k + m;
            
        } else {
            amount[0] -= (k + m);
            amount[1] -= k;
            // cout<<res<<k<<m<<amount[1];
            return res + 2 * k + m + amount[1];
            
        }
    }
};
```

其实很简单的问题

```c++
class Solution {
public:
    int fillCups(vector<int>& amount) {
       int mx = 0, sum = 0;
        for(int& num: amount) {
            mx = max(num, mx);
            sum += num;
        }
        return max(mx, (sum + 1) / 2); 
    }
};
```



### [2336. Smallest Number in Infinite Set](https://leetcode.com/problems/smallest-number-in-infinite-set/)

You have a set which contains all positive integers `[1, 2, 3, 4, 5, ...]`.

Implement the `SmallestInfiniteSet` class:

- `SmallestInfiniteSet()` Initializes the **SmallestInfiniteSet** object to contain **all** positive integers.
- `int popSmallest()` **Removes** and returns the smallest integer contained in the infinite set.
- `void addBack(int num)` **Adds** a positive integer `num` back into the infinite set, if it is **not** already in the infinite set.

 

**Example 1:**

```
Input
["SmallestInfiniteSet", "addBack", "popSmallest", "popSmallest", "popSmallest", "addBack", "popSmallest", "popSmallest", "popSmallest"]
[[], [2], [], [], [], [1], [], [], []]
Output
[null, null, 1, 2, 3, null, 1, 4, 5]

Explanation
SmallestInfiniteSet smallestInfiniteSet = new SmallestInfiniteSet();
smallestInfiniteSet.addBack(2);    // 2 is already in the set, so no change is made.
smallestInfiniteSet.popSmallest(); // return 1, since 1 is the smallest number, and remove it from the set.
smallestInfiniteSet.popSmallest(); // return 2, and remove it from the set.
smallestInfiniteSet.popSmallest(); // return 3, and remove it from the set.
smallestInfiniteSet.addBack(1);    // 1 is added back to the set.
smallestInfiniteSet.popSmallest(); // return 1, since 1 was added back to the set and
                                   // is the smallest number, and remove it from the set.
smallestInfiniteSet.popSmallest(); // return 4, and remove it from the set.
smallestInfiniteSet.popSmallest(); // return 5, and remove it from the set.
```

 

**Constraints:**

- `1 <= num <= 1000`
- At most `1000` calls will be made **in total** to `popSmallest` and `addBack`.

Medium，我是使用栈

```c++
class SmallestInfiniteSet {
stack<int> stk;
public:
    SmallestInfiniteSet() {
        stk.push(1);
    }
    
    int popSmallest() {
        int res = stk.top();
        stk.pop();
        if (stk.size() == 0) stk.push(res + 1);
        return res;
    }
    
    void addBack(int num) {
        stack<int> tmp;
        while (stk.size() && stk.top() < num) {
            tmp.push(stk.top());
            stk.pop();
        }
        if (stk.size() > 0) {
            if (stk.top() > num) {
                stk.push(num);
            }
        }
        while (tmp.size()) {
            stk.push(tmp.top());
            tmp.pop();
        }
    }
};

/**
 * Your SmallestInfiniteSet object will be instantiated and called as such:
 * SmallestInfiniteSet* obj = new SmallestInfiniteSet();
 * int param_1 = obj->popSmallest();
 * obj->addBack(num);
 */
```

或者用优先队列/set也可以解决，下面是使用priority_queueQQ

```c++
class SmallestInfiniteSet {
public:
    priority_queue<int, vector<int>, greater<int>>q;
    unordered_map<int, bool>m;
    SmallestInfiniteSet() {
        // 插入1000个数到容器中，并更新map
        for(int i = 1; i <= 1000; i++) {
            q.push(i);
            m[i] = true;
        }
        
    }
    
    int popSmallest() {
        int a = q.top();
        q.pop();
        m[a] = false; // map记录这个数字为空
        return a;
    }
    
    void addBack(int num) {
        // 如果字典存在这个数字，但为空，插入
        if (m.count(num)) { 
            if(m[num] == false) q.push(num);
            m[num]=true;
        } else { // 容器没这个数字，直接插入
            q.push(num);
            m[num] = true;
        }
    }
};

/**
 * Your SmallestInfiniteSet object will be instantiated and called as such:
 * SmallestInfiniteSet* obj = new SmallestInfiniteSet();
 * int param_1 = obj->popSmallest();
 * obj->addBack(num);
 */
```

使用set

```c++
class SmallestInfiniteSet {
public:
    set<int>s;
    SmallestInfiniteSet() {
        s.clear();
        for(int i = 1; i <= 1010; i++) s.insert(i);
    }
    
    int popSmallest() {
        int x = *s.begin();
        s.erase(s.begin());
        return x;
    }
    
    void addBack(int num) {
        s.insert(num);
    }
};

/**
 * Your SmallestInfiniteSet object will be instantiated and called as such:
 * SmallestInfiniteSet* obj = new SmallestInfiniteSet();
 * int param_1 = obj->popSmallest();
 * obj->addBack(num);
 */
```



### [2337. Move Pieces to Obtain a String](https://leetcode.com/problems/move-pieces-to-obtain-a-string/)

You are given two strings `start` and `target`, both of length `n`. Each string consists **only** of the characters `'L'`, `'R'`, and `'_'` where:

- The characters `'L'` and `'R'` represent pieces, where a piece `'L'` can move to the **left** only if there is a **blank** space directly to its left, and a piece `'R'` can move to the **right** only if there is a **blank** space directly to its right.
- The character `'_'` represents a blank space that can be occupied by **any** of the `'L'` or `'R'` pieces.

Return `true` *if it is possible to obtain the string* `target` *by moving the pieces of the string* `start` ***any** number of times*. Otherwise, return `false`.

 

**Example 1:**

```
Input: start = "_L__R__R_", target = "L______RR"
Output: true
Explanation: We can obtain the string target from start by doing the following moves:
- Move the first piece one step to the left, start becomes equal to "L___R__R_".
- Move the last piece one step to the right, start becomes equal to "L___R___R".
- Move the second piece three steps to the right, start becomes equal to "L______RR".
Since it is possible to get the string target from start, we return true.
```

**Example 2:**

```
Input: start = "R_L_", target = "__LR"
Output: false
Explanation: The 'R' piece in the string start can move one step to the right to obtain "_RL_".
After that, no pieces can move anymore, so it is impossible to obtain the string target from start.
```

**Example 3:**

```
Input: start = "_R", target = "R_"
Output: false
Explanation: The piece in the string start can move only to the right, so it is impossible to obtain the string target from start.
```

 

**Constraints:**

- `n == start.length == target.length`
- `1 <= n <= 105`
- `start` and `target` consist of the characters `'L'`, `'R'`, and `'_'`.

Medium，L和R数量一致，每个L和R相对位置一致，L只能向左，R只能向右

```c++
class Solution {
public:
    bool canChange(string start, string target) {
        int lNum = 0, rNum = 0;
        vector<int> lPos, rPos;
        vector<int> lRight, rLeft;
        int n = start.size();
        for (int i = 0; i < n; i++) {
            if (start[i] == 'L') {
                lPos.push_back(i);
                lRight.push_back(rNum);
                lNum++;
            } else if (start[i] == 'R') {
                rPos.push_back(i);
                rLeft.push_back(lNum);
                rNum++;
            }
        }
        lNum = 0, rNum = 0;
        for (int i = 0; i < n; i++) {
            if (target[i] == 'L') {
                if (lNum >= lPos.size()) return false;
                if (i > lPos[lNum]) return false;
                if (lRight[lNum] != rNum) return false;
                lNum++;
            } else if (target[i] == 'R') {
                if (rNum >= rPos.size()) return false;
                if (i < rPos[rNum]) return false;
                if (rLeft[rNum] != lNum) return false;
                rNum++;
            }
        }
        if (lNum != lPos.size() || rNum != rPos.size()) return false;
        return true;
    }
};
```

双指针遍历2个字符串

```c++
class Solution {
public:
    bool canChange(string start, string target) {
        int i = 0, j = 0, n = start.length();
        while(i < n && j < n){
            while(i < n && start[i++] == '_');
            while(j < n && target[j++] == '_');
            i--;
            j--;
            if (start[i] != target[j]) return false;
            if (start[i] == 'L') {
                if (i < j) return false;
            }
            if (start[i] == 'R') {
                if (i > j) return false;
            }
            i++;
            j++;
        }
        return true;
    }
};
```



### Failed: [2338. Count the Number of Ideal Arrays](https://leetcode.com/problems/count-the-number-of-ideal-arrays/)

You are given two integers `n` and `maxValue`, which are used to describe an **ideal** array.

A **0-indexed** integer array `arr` of length `n` is considered **ideal** if the following conditions hold:

- Every `arr[i]` is a value from `1` to `maxValue`, for `0 <= i < n`.
- Every `arr[i]` is divisible by `arr[i - 1]`, for `0 < i < n`.

Return *the number of **distinct** ideal arrays of length* `n`. Since the answer may be very large, return it modulo `109 + 7`.

 

**Example 1:**

```
Input: n = 2, maxValue = 5
Output: 10
Explanation: The following are the possible ideal arrays:
- Arrays starting with the value 1 (5 arrays): [1,1], [1,2], [1,3], [1,4], [1,5]
- Arrays starting with the value 2 (2 arrays): [2,2], [2,4]
- Arrays starting with the value 3 (1 array): [3,3]
- Arrays starting with the value 4 (1 array): [4,4]
- Arrays starting with the value 5 (1 array): [5,5]
There are a total of 5 + 2 + 1 + 1 + 1 = 10 distinct ideal arrays.
```

**Example 2:**

```
Input: n = 5, maxValue = 3
Output: 11
Explanation: The following are the possible ideal arrays:
- Arrays starting with the value 1 (9 arrays): 
   - With no other distinct values (1 array): [1,1,1,1,1] 
   - With 2nd distinct value 2 (4 arrays): [1,1,1,1,2], [1,1,1,2,2], [1,1,2,2,2], [1,2,2,2,2]
   - With 2nd distinct value 3 (4 arrays): [1,1,1,1,3], [1,1,1,3,3], [1,1,3,3,3], [1,3,3,3,3]
- Arrays starting with the value 2 (1 array): [2,2,2,2,2]
- Arrays starting with the value 3 (1 array): [3,3,3,3,3]
There are a total of 9 + 1 + 1 = 11 distinct ideal arrays.
```

 

**Constraints:**

- `2 <= n <= 104`
- `1 <= maxValue <= 104`

Hard，小于maxValue的所有数分解质因数，再进行计算

```c++
class Solution {
    const int MOD = 1000000007;
    vector<long long> inv;

    // O(b) 求组合数
    long long C(int a, int b) {
        if (b > a) return 0;
        long long ret = 1;
        for (int i = 1; i <= b; i++) ret = (ret * (a - i + 1) % MOD * inv[i]) % MOD;
        return ret;
    }

public:
    int idealArrays(int n, int K) {
        // nlnn 进行质因数分解，f[i] 的元素表示 i 的每种质因数的指数
        vector<vector<int>> f(K + 1);
        int mx = 0;
        for (int i = 2; i <= K; i++) if (f[i].empty()) for (int j = i; j <= K; j += i) {
            int x = j, y = 0;
            for (; x % i == 0; x /= i) y++;
            f[j].push_back(y);
            mx = max(mx, y);
        }

        // 线性求逆元
        inv.resize(mx + 5);
        inv[1] = 1;
        for (int i = 2; i <= mx; i++) inv[i] = (MOD - MOD / i) * inv[MOD % i] % MOD;

        // 统计答案
        long long ans = 0;
        for (int i = 1; i <= K; i++) {
            long long t = 1;
            for (int x : f[i]) t = (t * C(n + x - 1, x)) % MOD;
            ans = (ans + t) % MOD;
        }
        return ans;
    }
};
```



## [Weekly Contest 302](https://leetcode.com/contest/weekly-contest-302/)

![image-20220718090303244](https://cdn.jsdelivr.net/gh/huxingyi1997/my_img/img/20220718090335.png)



### [2341. Maximum Number of Pairs in Array](https://leetcode.com/problems/maximum-number-of-pairs-in-array/)

You are given a **0-indexed** integer array `nums`. In one operation, you may do the following:

- Choose **two** integers in `nums` that are **equal**.
- Remove both integers from `nums`, forming a **pair**.

The operation is done on `nums` as many times as possible.

Return *a **0-indexed** integer array* `answer` *of size* `2` *where* `answer[0]` *is the number of pairs that are formed and* `answer[1]` *is the number of leftover integers in* `nums` *after doing the operation as many times as possible*.

 

**Example 1:**

```
Input: nums = [1,3,2,1,3,2,2]
Output: [3,1]
Explanation:
Form a pair with nums[0] and nums[3] and remove them from nums. Now, nums = [3,2,3,2,2].
Form a pair with nums[0] and nums[2] and remove them from nums. Now, nums = [2,2,2].
Form a pair with nums[0] and nums[1] and remove them from nums. Now, nums = [2].
No more pairs can be formed. A total of 3 pairs have been formed, and there is 1 number leftover in nums.
```

**Example 2:**

```
Input: nums = [1,1]
Output: [1,0]
Explanation: Form a pair with nums[0] and nums[1] and remove them from nums. Now, nums = [].
No more pairs can be formed. A total of 1 pair has been formed, and there are 0 numbers leftover in nums.
```

**Example 3:**

```
Input: nums = [0]
Output: [0,1]
Explanation: No pairs can be formed, and there is 1 number leftover in nums.
```

 

**Constraints:**

- `1 <= nums.length <= 100`
- `0 <= nums[i] <= 100`

Easy，计算每个数出现次数是奇数还是偶数

```c++
class Solution {
public:
    vector<int> numberOfPairs(vector<int>& nums) {
        vector<int> countNums(101, 0);
        int odd = 0, even = 0;
        for (int num: nums) {
            countNums[num]++;
            if (countNums[num] % 2 == 1) {
                odd++;
            } else {
                even++;
                odd--;
            }
        }
        return {even, odd};
    }
};
```



### [2342. Max Sum of a Pair With Equal Sum of Digits](https://leetcode.com/problems/max-sum-of-a-pair-with-equal-sum-of-digits/)

You are given a **0-indexed** array `nums` consisting of **positive** integers. You can choose two indices `i` and `j`, such that `i != j`, and the sum of digits of the number `nums[i]` is equal to that of `nums[j]`.

Return *the **maximum** value of* `nums[i] + nums[j]` *that you can obtain over all possible indices* `i` *and* `j` *that satisfy the conditions.*

 

**Example 1:**

```
Input: nums = [18,43,36,13,7]
Output: 54
Explanation: The pairs (i, j) that satisfy the conditions are:
- (0, 2), both numbers have a sum of digits equal to 9, and their sum is 18 + 36 = 54.
- (1, 4), both numbers have a sum of digits equal to 7, and their sum is 43 + 7 = 50.
So the maximum sum that we can obtain is 54.
```

**Example 2:**

```
Input: nums = [10,12,19,14]
Output: -1
Explanation: There are no two numbers that satisfy the conditions, so we return -1.
```

 

**Constraints:**

- `1 <= nums.length <= 105`
- `1 <= nums[i] <= 109`

Medium，计算位数相同的数，保留最大的两个

```c++
class Solution {
public:
    int maximumSum(vector<int>& nums) {
        int res = -1;
        vector<vector<int>> digitSumWithMAxTwo (82, vector<int> (3, 0));
        for (int num: nums) {
            int digitSum = countDigitSum(num);
            digitSumWithMAxTwo[digitSum][0]++;
            if (digitSumWithMAxTwo[digitSum][1] == 0) {
                digitSumWithMAxTwo[digitSum][1] = num;
            } else if (digitSumWithMAxTwo[digitSum][2] == 0) {
                digitSumWithMAxTwo[digitSum][2] = num;
            } else if (num > digitSumWithMAxTwo[digitSum][1]) {
                digitSumWithMAxTwo[digitSum][2] = digitSumWithMAxTwo[digitSum][1];
                digitSumWithMAxTwo[digitSum][1] = num;
            } else if (num > digitSumWithMAxTwo[digitSum][2]) {
                digitSumWithMAxTwo[digitSum][2] = num;
            }
            // cout<<digitSum<<","<<digitSumWithMAxTwo[digitSum][0]<<","<<digitSumWithMAxTwo[digitSum][1]<<","<<digitSumWithMAxTwo[digitSum][2]<<endl;
            if (digitSumWithMAxTwo[digitSum][0] > 1) {
                if (digitSumWithMAxTwo[digitSum][1] < digitSumWithMAxTwo[digitSum][2]) {
                    int temp = digitSumWithMAxTwo[digitSum][1];
                    digitSumWithMAxTwo[digitSum][1] = digitSumWithMAxTwo[digitSum][2];
                    digitSumWithMAxTwo[digitSum][2] = temp;
                }
                res = max(res, digitSumWithMAxTwo[digitSum][1] + digitSumWithMAxTwo[digitSum][2]);
            }
        }
        return res;
    }
    int countDigitSum(int num) {
        int res = 0;
        while (num != 0) {
            res += num % 10;
            num = num / 10;
        }
        return res;
    }
};
```



### [2343. Query Kth Smallest Trimmed Number](https://leetcode.com/problems/query-kth-smallest-trimmed-number/)

You are given a **0-indexed** array of strings `nums`, where each string is of **equal length** and consists of only digits.

You are also given a **0-indexed** 2D integer array `queries` where `queries[i] = [ki, trimi]`. For each `queries[i]`, you need to:

- **Trim** each number in `nums` to its **rightmost** `trimi` digits.
- Determine the **index** of the `kith` smallest trimmed number in `nums`. If two trimmed numbers are equal, the number with the **lower** index is considered to be smaller.
- Reset each number in `nums` to its original length.

Return *an array* `answer` *of the same length as* `queries`, *where* `answer[i]` *is the answer to the* `ith` *query.*

**Note**:

- To trim to the rightmost `x` digits means to keep removing the leftmost digit, until only `x` digits remain.
- Strings in `nums` may contain leading zeros.

 

**Example 1:**

```
Input: nums = ["102","473","251","814"], queries = [[1,1],[2,3],[4,2],[1,2]]
Output: [2,2,1,0]
Explanation:
1. After trimming to the last digit, nums = ["2","3","1","4"]. The smallest number is 1 at index 2.
2. Trimmed to the last 3 digits, nums is unchanged. The 2nd smallest number is 251 at index 2.
3. Trimmed to the last 2 digits, nums = ["02","73","51","14"]. The 4th smallest number is 73.
4. Trimmed to the last 2 digits, the smallest number is 2 at index 0.
   Note that the trimmed number "02" is evaluated as 2.
```

**Example 2:**

```
Input: nums = ["24","37","96","04"], queries = [[2,1],[2,2]]
Output: [3,0]
Explanation:
1. Trimmed to the last digit, nums = ["4","7","6","4"]. The 2nd smallest number is 4 at index 3.
   There are two occurrences of 4, but the one at index 0 is considered smaller than the one at index 3.
2. Trimmed to the last 2 digits, nums is unchanged. The 2nd smallest number is 24.
```

 

**Constraints:**

- `1 <= nums.length <= 100`
- `1 <= nums[i].length <= 100`
- `nums[i]` consists of only digits.
- All `nums[i].length` are **equal**.
- `1 <= queries.length <= 100`
- `queries[i].length == 2`
- `1 <= ki <= nums.length`
- `1 <= trimi <= nums[i].length`

Medium，保存后几位数的大小排序并保存原索引

```c++
class Solution {
public:
    vector<int> smallestTrimmedNumbers(vector<string>& nums, vector<vector<int>>& queries) {
        vector<bool> isSearched(100, false);
        vector<vector<pair<string, int>>> smallestTrimmedInorder(100);
        vector<int> res;
        for (auto &query: queries) {
            if (isSearched[query[1] - 1]) {
                res.push_back(smallestTrimmedInorder[query[1] - 1][query[0] - 1].second);
            } else {
                isSearched[query[1] - 1] = true;
                vector<pair<string, int>> arr;
                for (int j = 0; j < nums.size(); j++) {
                    string sub = nums[j].substr(nums[j].size() - query[1]);
                    arr.push_back(make_pair(sub, j));
                }
                sort(arr.begin(), arr.end());
                smallestTrimmedInorder[query[1] - 1] = arr;
                res.push_back(smallestTrimmedInorder[query[1] - 1][query[0] - 1].second);
            }
            
        }
        return res;
    }
};
```



### [2344. Minimum Deletions to Make Array Divisible](https://leetcode.com/problems/minimum-deletions-to-make-array-divisible/)

You are given two positive integer arrays `nums` and `numsDivide`. You can delete any number of elements from `nums`.

Return *the **minimum** number of deletions such that the **smallest** element in* `nums` ***divides** all the elements of* `numsDivide`. If this is not possible, return `-1`.

Note that an integer `x` divides `y` if `y % x == 0`.

 

**Example 1:**

```
Input: nums = [2,3,2,4,3], numsDivide = [9,6,9,3,15]
Output: 2
Explanation: 
The smallest element in [2,3,2,4,3] is 2, which does not divide all the elements of numsDivide.
We use 2 deletions to delete the elements in nums that are equal to 2 which makes nums = [3,4,3].
The smallest element in [3,4,3] is 3, which divides all the elements of numsDivide.
It can be shown that 2 is the minimum number of deletions needed.
```

**Example 2:**

```
Input: nums = [4,3,6], numsDivide = [8,2,6,10]
Output: -1
Explanation: 
We want the smallest element in nums to divide all the elements of numsDivide.
There is no way to delete elements from nums to allow this.
```

 

**Constraints:**

- `1 <= nums.length, numsDivide.length <= 105`
- `1 <= nums[i], numsDivide[i] <= 109`

Hard，求最大公约数

```c++
class Solution {
public:
    int minOperations(vector<int>& nums, vector<int>& numsDivide) {
        int gcdNum = gcd(numsDivide);
        sort(nums.begin(), nums.end());
        for (int i = 0; i < nums.size(); i++) {
            if (nums[i] > gcdNum) return -1;
            if (gcdNum % nums[i] == 0) {
                return i;
            }
        }
        return -1;
    }
    int gcd(vector<int> nums) {
        int res = nums[0];
        for (int i = 1; i < nums.size(); i++) {
            res = gcdTwoNum(res, nums[i]);
            if (res == 1) return 1;
        }
        return res;
    }
    int gcdTwoNum(int num1, int num2) {
        if (num1 > num2) {
            return gcdTwoNum(num2, num1);
        }
        while (num1 != 1) {
            int q = num2 % num1;
            if (q == 0) {
                return num1;
            }
            num2 = num1;
            num1 = q;
        }
        return num1;
    }
};
```



## [Weekly Contest 303](https://leetcode.com/contest/weekly-contest-303/)

![image-20220724222811908](https://cdn.jsdelivr.net/gh/huxingyi1997/my_img/img/20220724222818.png)



### [2351. First Letter to Appear Twice](https://leetcode.com/problems/first-letter-to-appear-twice/)

Given a string `s` consisting of lowercase English letters, return *the first letter to appear **twice***.

**Note**:

- A letter `a` appears twice before another letter `b` if the **second** occurrence of `a` is before the **second** occurrence of `b`.
- `s` will contain at least one letter that appears twice.

 

**Example 1:**

```
Input: s = "abccbaacz"
Output: "c"
Explanation:
The letter 'a' appears on the indexes 0, 5 and 6.
The letter 'b' appears on the indexes 1 and 4.
The letter 'c' appears on the indexes 2, 3 and 7.
The letter 'z' appears on the index 8.
The letter 'c' is the first letter to appear twice, because out of all the letters the index of its second occurrence is the smallest.
```

**Example 2:**

```
Input: s = "abcdd"
Output: "d"
Explanation:
The only letter that appears twice is 'd' so we return 'd'.
```

 

**Constraints:**

- `2 <= s.length <= 100`
- `s` consists of lowercase English letters.
- `s` has at least one repeated letter.

Easy，哈希

```c++
class Solution {
public:
    char repeatedCharacter(string s) {
        vector<bool> isVisited(26, false);
        for (char c: s) {
            if (isVisited[c - 'a'] == true) {
                return c;
            }
            isVisited[c - 'a'] = true;
        }
        return 'a';
    }
};
```



### [2352. Equal Row and Column Pairs](https://leetcode.com/problems/equal-row-and-column-pairs/)

Given a **0-indexed** `n x n` integer matrix `grid`, *return the number of pairs* `(Ri, Cj)` *such that row* `Ri` *and column* `Cj` *are equal*.

A row and column pair is considered equal if they contain the same elements in the same order (i.e. an equal array).

 

**Example 1:**

![img](https://cdn.jsdelivr.net/gh/huxingyi1997/my_img/img/20220724224120.jpeg)

```
Input: grid = [[3,2,1],[1,7,6],[2,7,7]]
Output: 1
Explanation: There is 1 equal row and column pair:
- (Row 2, Column 1): [2,7,7]
```

**Example 2:**

![img](https://cdn.jsdelivr.net/gh/huxingyi1997/my_img/img/20220724224146.jpeg)

```
Input: grid = [[3,1,2,2],[1,4,4,5],[2,4,2,2],[2,4,2,2]]
Output: 3
Explanation: There are 3 equal row and column pairs:
- (Row 0, Column 0): [3,1,2,2]
- (Row 2, Column 2): [2,4,2,2]
- (Row 3, Column 2): [2,4,2,2]
```

 

**Constraints:**

- `n == grid.length == grid[i].length`
- `1 <= n <= 200`
- `1 <= grid[i][j] <= 105`

Medium，拼接字符串+哈希

```c++
class Solution {
public:
    int equalPairs(vector<vector<int>>& grid) {
        int res = 0;
        int n = grid.size();
        unordered_map<string, int> dic;
        for (int i = 0; i < n; i++) {
            string row;
            for (int j = 0; j < n; j++) {
                row += to_string (grid[i][j]);
                row += ',';
            }
            dic[row]++;
        }
        
        for (int i = 0; i < n; i++) {
            string col;
            for (int j = 0; j < n; j++) {
                col += to_string (grid[j][i]);
                col += ',';
            }
            if (dic.count(col)) res += dic[col];
        }
        return res;
    }
};
```



### Failed: [2353. Design a Food Rating System](https://leetcode.com/problems/design-a-food-rating-system/)

Design a food rating system that can do the following:

- **Modify** the rating of a food item listed in the system.
- Return the highest-rated food item for a type of cuisine in the system.

Implement the `FoodRatings` class:

- `FoodRatings(String[] foods, String[] cuisines, int[] ratings)`

  Initializes the system. The food items are described by`foods`,`cuisines`and`ratings`, all of which have a length of`n`.

  - `foods[i]` is the name of the `ith` food,
  - `cuisines[i]` is the type of cuisine of the `ith` food, and
  - `ratings[i]` is the initial rating of the `ith` food.
  
- `void changeRating(String food, int newRating)` Changes the rating of the food item with the name `food`.

- `String highestRated(String cuisine)` Returns the name of the food item that has the highest rating for the given type of `cuisine`. If there is a tie, return the item with the **lexicographically smaller** name.

Note that a string `x` is lexicographically smaller than string `y` if `x` comes before `y` in dictionary order, that is, either `x` is a prefix of `y`, or if `i` is the first position such that `x[i] != y[i]`, then `x[i]` comes before `y[i]` in alphabetic order.

 

**Example 1:**

```
Input
["FoodRatings", "highestRated", "highestRated", "changeRating", "highestRated", "changeRating", "highestRated"]
[[["kimchi", "miso", "sushi", "moussaka", "ramen", "bulgogi"], ["korean", "japanese", "japanese", "greek", "japanese", "korean"], [9, 12, 8, 15, 14, 7]], ["korean"], ["japanese"], ["sushi", 16], ["japanese"], ["ramen", 16], ["japanese"]]
Output
[null, "kimchi", "ramen", null, "sushi", null, "ramen"]

Explanation
FoodRatings foodRatings = new FoodRatings(["kimchi", "miso", "sushi", "moussaka", "ramen", "bulgogi"], ["korean", "japanese", "japanese", "greek", "japanese", "korean"], [9, 12, 8, 15, 14, 7]);
foodRatings.highestRated("korean"); // return "kimchi"
                                    // "kimchi" is the highest rated korean food with a rating of 9.
foodRatings.highestRated("japanese"); // return "ramen"
                                      // "ramen" is the highest rated japanese food with a rating of 14.
foodRatings.changeRating("sushi", 16); // "sushi" now has a rating of 16.
foodRatings.highestRated("japanese"); // return "sushi"
                                      // "sushi" is the highest rated japanese food with a rating of 16.
foodRatings.changeRating("ramen", 16); // "ramen" now has a rating of 16.
foodRatings.highestRated("japanese"); // return "ramen"
                                      // Both "sushi" and "ramen" have a rating of 16.
                                      // However, "ramen" is lexicographically smaller than "sushi".
```

 

**Constraints:**

- `1 <= n <= 2 * 104`
- `n == foods.length == cuisines.length == ratings.length`
- `1 <= foods[i].length, cuisines[i].length <= 10`
- `foods[i]`, `cuisines[i]` consist of lowercase English letters.
- `1 <= ratings[i] <= 108`
- All the strings in `foods` are **distinct**.
- `food` will be the name of a food item in the system across all calls to `changeRating`.
- `cuisine` will be a type of cuisine of **at least one** food item in the system across all calls to `highestRated`.
- At most `2 * 104` calls **in total** will be made to `changeRating` and `highestRated`.

Medium，STL接口不熟悉，哎

```c++
class FoodRatings {
public:
    struct Cmp {
        bool operator () (const pair<int, string>&a, const pair<int, string>&b) const {
            if (a.first == b.first)
                return a.second < b.second;
            return a.first > b.first;
        }
    };
	unordered_map<string, pair<int, string>> foodDic;
	unordered_map<string, set<pair<int, string>, Cmp>> cuisineDic;
	FoodRatings(vector<string>& foods, vector<string>& cuisines, vector<int>& ratings) {
		for (int i = 0; i < foods.size(); i++) {
			foodDic[foods[i]]= make_pair(ratings[i], cuisines[i]);
			cuisineDic[cuisines[i]].insert(make_pair(ratings[i], foods[i]));
		}
	}

	void changeRating(string food, int newRating) {
		string cuisine = foodDic[food].second;
		int rate = foodDic[food].first;
		cuisineDic[cuisine].erase(make_pair(rate, food));
		cuisineDic[cuisine].insert(make_pair(newRating, food));
        foodDic[food]= make_pair(newRating, cuisine);
	}

	string highestRated(string cuisine) {
		return cuisineDic[cuisine].begin()->second;
	}
};
/**
 * Your FoodRatings object will be instantiated and called as such:
 * FoodRatings* obj = new FoodRatings(foods, cuisines, ratings);
 * obj->changeRating(food,newRating);
 * string param_2 = obj->highestRated(cuisine);
 */
```



### Failed: [2354. Number of Excellent Pairs](https://leetcode.com/problems/number-of-excellent-pairs/)

You are given a **0-indexed** positive integer array `nums` and a positive integer `k`.

A pair of numbers `(num1, num2)` is called **excellent** if the following conditions are satisfied:

- **Both** the numbers `num1` and `num2` exist in the array `nums`.
- The sum of the number of set bits in `num1 OR num2` and `num1 AND num2` is greater than or equal to `k`, where `OR` is the bitwise **OR** operation and `AND` is the bitwise **AND** operation.

Return *the number of **distinct** excellent pairs*.

Two pairs `(a, b)` and `(c, d)` are considered distinct if either `a != c` or `b != d`. For example, `(1, 2)` and `(2, 1)` are distinct.

**Note** that a pair `(num1, num2)` such that `num1 == num2` can also be excellent if you have at least **one** occurrence of `num1` in the array.

 

**Example 1:**

```
Input: nums = [1,2,3,1], k = 3
Output: 5
Explanation: The excellent pairs are the following:
- (3, 3). (3 AND 3) and (3 OR 3) are both equal to (11) in binary. The total number of set bits is 2 + 2 = 4, which is greater than or equal to k = 3.
- (2, 3) and (3, 2). (2 AND 3) is equal to (10) in binary, and (2 OR 3) is equal to (11) in binary. The total number of set bits is 1 + 2 = 3.
- (1, 3) and (3, 1). (1 AND 3) is equal to (01) in binary, and (1 OR 3) is equal to (11) in binary. The total number of set bits is 1 + 2 = 3.
So the number of excellent pairs is 5.
```

**Example 2:**

```
Input: nums = [5,1,1], k = 10
Output: 0
Explanation: There are no excellent pairs for this array.
```

 

**Constraints:**

- `1 <= nums.length <= 105`
- `1 <= nums[i] <= 109`
- `1 <= k <= 60`

Hard，其实就是求每个数有多少1

```c++
class Solution {
public:
    long long countExcellentPairs(vector<int>& nums, int k) {
        long long res = 0;
        unordered_map<int, int> bitCounts;
        for (int num: unordered_set<int>(nums.begin(), nums.end())) {
            bitCounts[__builtin_popcount(num)]++;
        }
        for (auto &[cx, ccx] : bitCounts) {
            for (auto &[cy, ccy] : bitCounts) {
                if (cx + cy >= k) {
                    res += ccx * ccy;
                }
            }
        }
        return res;
    }
};
```



## [Weekly Contest 304](https://leetcode.com/contest/weekly-contest-304/)

![image-20220801091222647](https://cdn.jsdelivr.net/gh/huxingyi1997/my_img/img/20220801091228.png)



### [2357. Make Array Zero by Subtracting Equal Amounts](https://leetcode.com/problems/make-array-zero-by-subtracting-equal-amounts/)

You are given a non-negative integer array `nums`. In one operation, you must:

- Choose a positive integer `x` such that `x` is less than or equal to the **smallest non-zero** element in `nums`.
- Subtract `x` from every **positive** element in `nums`.

Return *the **minimum** number of operations to make every element in* `nums` *equal to* `0`.

 

**Example 1:**

```
Input: nums = [1,5,0,3,5]
Output: 3
Explanation:
In the first operation, choose x = 1. Now, nums = [0,4,0,2,4].
In the second operation, choose x = 2. Now, nums = [0,2,0,0,2].
In the third operation, choose x = 2. Now, nums = [0,0,0,0,0].
```

**Example 2:**

```
Input: nums = [0]
Output: 0
Explanation: Each element in nums is already 0 so no operations are needed.
```

 

**Constraints:**

- `1 <= nums.length <= 100`
- `0 <= nums[i] <= 100`

Easy，保存每一轮之后的数据

```c++
class Solution {
public:
    int minimumOperations(vector<int>& nums) {
        set<int> pos;
        for (int num: nums) {
            if (num > 0) {
                pos.insert(num);
            }
        }
        int ans = 0;
        while (pos.size() > 0) {
            auto it = pos.begin();
            int min_num = *it;
            set<int> temp;
            for (; it != pos.end(); it++) {
                if (*it > min_num) {
                    temp.insert(*it - min_num);
                }
            }
            pos = temp;
            ans++;
        }
        return ans;
    }
};
```



### Failed: [2358. Maximum Number of Groups Entering a Competition](https://leetcode.com/problems/maximum-number-of-groups-entering-a-competition/)

You are given a positive integer array `grades` which represents the grades of students in a university. You would like to enter **all** these students into a competition in **ordered** non-empty groups, such that the ordering meets the following conditions:

- The sum of the grades of students in the `ith` group is **less than** the sum of the grades of students in the `(i + 1)th` group, for all groups (except the last).
- The total number of students in the `ith` group is **less than** the total number of students in the `(i + 1)th` group, for all groups (except the last).

Return *the **maximum** number of groups that can be formed*.

 

**Example 1:**

```
Input: grades = [10,6,12,7,3,5]
Output: 3
Explanation: The following is a possible way to form 3 groups of students:
- 1st group has the students with grades = [12]. Sum of grades: 12. Student count: 1
- 2nd group has the students with grades = [6,7]. Sum of grades: 6 + 7 = 13. Student count: 2
- 3rd group has the students with grades = [10,3,5]. Sum of grades: 10 + 3 + 5 = 18. Student count: 3
It can be shown that it is not possible to form more than 3 groups.
```

**Example 2:**

```
Input: grades = [8,8]
Output: 1
Explanation: We can only form 1 group, since forming 2 groups would lead to an equal number of students in both groups.
```

 

**Constraints:**

- `1 <= grades.length <= 105`
- `1 <= grades[i] <= 105`

Medium，关键得找到数目也是增序这一条件。

```c++
class Solution {
public:
    int maximumGroups(vector<int>& grades) {
        int n = grades.size();
        int total = 0, cur = 0;
        while (total + cur + 1 <= n) {
            total += ++cur;
        }
        return cur;
    }
};
```

是用数学方法进行简化

```c++
class Solution {
public:
    int maximumGroups(vector<int>& grades) {
        return (int)(sqrt(grades.size() * 2 + 0.25) - 0.5);
    }
};
```



### [2359. Find Closest Node to Given Two Nodes](https://leetcode.com/problems/find-closest-node-to-given-two-nodes/)

You are given a **directed** graph of `n` nodes numbered from `0` to `n - 1`, where each node has **at most one** outgoing edge.

The graph is represented with a given **0-indexed** array `edges` of size `n`, indicating that there is a directed edge from node `i` to node `edges[i]`. If there is no outgoing edge from `i`, then `edges[i] == -1`.

You are also given two integers `node1` and `node2`.

Return *the **index** of the node that can be reached from both* `node1` *and* `node2`*, such that the **maximum** between the distance from* `node1` *to that node, and from* `node2` *to that node is **minimized***. If there are multiple answers, return the node with the **smallest** index, and if no possible answer exists, return `-1`.

Note that `edges` may contain cycles.

 

**Example 1:**

![img](https://assets.leetcode.com/uploads/2022/06/07/graph4drawio-2.png)

```
Input: edges = [2,2,3,-1], node1 = 0, node2 = 1
Output: 2
Explanation: The distance from node 0 to node 2 is 1, and the distance from node 1 to node 2 is 1.
The maximum of those two distances is 1. It can be proven that we cannot get a node with a smaller maximum distance than 1, so we return node 2.
```

**Example 2:**

![img](https://cdn.jsdelivr.net/gh/huxingyi1997/my_img/img/20220802091148.png)

```
Input: edges = [1,2,-1], node1 = 0, node2 = 2
Output: 2
Explanation: The distance from node 0 to node 2 is 2, and the distance from node 2 to itself is 0.
The maximum of those two distances is 2. It can be proven that we cannot get a node with a smaller maximum distance than 2, so we return node 2.
```

 

**Constraints:**

- `n == edges.length`
- `2 <= n <= 105`
- `-1 <= edges[i] < n`
- `edges[i] != i`
- `0 <= node1, node2 < n`

Medium，使用哈希记录BFS路径，注意路径长度相同的情况

```c++
class Solution {
public:
    int closestMeetingNode(vector<int>& edges, int node1, int node2) {
        if (node1 == node2) return node1;
        int cur1 = node1, cur2 = node2;
        set<int> visited1, visited2;
        visited1.insert(cur1);
        visited2.insert(cur2);
        bool isCircle1 = false, isCircle2 = false;
        while ((isCircle1 == false && cur1 != -1) || (isCircle2 == false && cur2 != -1)) {
            int min1 = -1, min2 = -1;
            if (isCircle1 == false && cur1 != -1) {
                cur1 = edges[cur1];
                if (visited2.count(cur1)) min1 = cur1;
                if (visited1.count(cur1)) {
                    isCircle1 = true;
                } else {
                    visited1.insert(cur1);
                }
            }
            if (isCircle2 == false && cur2 != -1) {
                cur2 = edges[cur2];
                if (visited1.count(cur2)) min2 = cur2;
                if (visited2.count(cur2)) {
                    isCircle2 = true;
                } else {
                    visited2.insert(cur2);
                }
            }
            if (min1 > -1 || min2 > -1) {
                if (min1 > -1 && min2 > -1) {
                    return min(min1, min2);
                }
                return min1 > -1 ? min1 : min2;
            }
            
        }
        return -1;
    }
};
```



### 2360. Longest Cycle in a Graph

You are given a **directed** graph of `n` nodes numbered from `0` to `n - 1`, where each node has **at most one** outgoing edge.

The graph is represented with a given **0-indexed** array `edges` of size `n`, indicating that there is a directed edge from node `i` to node `edges[i]`. If there is no outgoing edge from node `i`, then `edges[i] == -1`.

Return *the length of the **longest** cycle in the graph*. If no cycle exists, return `-1`.

A cycle is a path that starts and ends at the **same** node.

 

**Example 1:**

![img](https://cdn.jsdelivr.net/gh/huxingyi1997/my_img/img/20220802091635.png)

```
Input: edges = [3,3,4,2,3]
Output: 3
Explanation: The longest cycle in the graph is the cycle: 2 -> 4 -> 3 -> 2.
The length of this cycle is 3, so 3 is returned.
```

**Example 2:**

![img](https://cdn.jsdelivr.net/gh/huxingyi1997/my_img/img/20220802091646.png)

```
Input: edges = [2,-1,3,1]
Output: -1
Explanation: There are no cycles in this graph.
```

 

**Constraints:**

- `n == edges.length`
- `2 <= n <= 105`
- `-1 <= edges[i] < n`
- `edges[i] != i`

Hard，顺序遍历未访问且入度大于1的节点

```c++
class Solution {
public:
    int longestCycle(vector<int>& edges) {
        int n = edges.size();
        vector<int> inDegree(n, 0);
        for (int i = 0; i < n; i++) {
            if (edges[i] != -1) {
                inDegree[edges[i]]++;
            }
        }
        vector<bool> isVisited(n, true);
        int count = 0;
        for (int i = 0; i < n; i++) {
            if (inDegree[i] > 0) {
                isVisited[i] = false;
                count++;
            }
        }
        int ans = -1;
        int index = 0;
        while (count > 0 && index < n) {
            while (isVisited[index] == true && index < n) {
                index++;
            }
            if (index == n) break;
            int cur = index;
            unordered_map<int, int> route;
            int order = 0;
            while (cur != -1) {
                if (route.count(cur)) {
                    ans = max(ans, order - route[cur]);
                    break;
                }
                route[cur] = order;
                order++;
                if (isVisited[cur]) {
                    break;
                } else {
                    isVisited[cur] = true;
                    count--;
                }
                cur = edges[cur];
            }
        }
        return ans;
    }
};
```



## [Weekly Contest 305](https://leetcode.com/contest/weekly-contest-305/)

![image-20220808075445305](https://cdn.jsdelivr.net/gh/huxingyi1997/my_img/img/20220808075451.png)



### [2367. Number of Arithmetic Triplets](https://leetcode.com/problems/number-of-arithmetic-triplets/)

You are given a **0-indexed**, **strictly increasing** integer array `nums` and a positive integer `diff`. A triplet `(i, j, k)` is an **arithmetic triplet** if the following conditions are met:

- `i < j < k`,
- `nums[j] - nums[i] == diff`, and
- `nums[k] - nums[j] == diff`.

Return *the number of unique **arithmetic triplets**.*

 

**Example 1:**

```
Input: nums = [0,1,4,6,7,10], diff = 3
Output: 2
Explanation:
(1, 2, 4) is an arithmetic triplet because both 7 - 4 == 3 and 4 - 1 == 3.
(2, 4, 5) is an arithmetic triplet because both 10 - 7 == 3 and 7 - 4 == 3. 
```

**Example 2:**

```
Input: nums = [4,5,6,7,8,9], diff = 2
Output: 2
Explanation:
(0, 2, 4) is an arithmetic triplet because both 8 - 6 == 2 and 6 - 4 == 2.
(1, 3, 5) is an arithmetic triplet because both 9 - 7 == 2 and 7 - 5 == 2.
```

 

**Constraints:**

- `3 <= nums.length <= 200`
- `0 <= nums[i] <= 200`
- `1 <= diff <= 50`
- `nums` is **strictly** increasing.

Easy，哈希

```c++
class Solution {
public:
    int arithmeticTriplets(vector<int>& nums, int diff) {
        unordered_set<int> dic;
        for (int num: nums) {
            dic.insert(num);
        }
        int res = 0;
        for (int i = 0; i < nums.size() - 1; i++) {
            if (dic.count(nums[i] + diff) && dic.count(nums[i] + 2 * diff)) {
                res++;
            }
        }
        return res;
    }
};
```



### [2368. Reachable Nodes With Restrictions](https://leetcode.com/problems/reachable-nodes-with-restrictions/)

There is an undirected tree with `n` nodes labeled from `0` to `n - 1` and `n - 1` edges.

You are given a 2D integer array `edges` of length `n - 1` where `edges[i] = [ai, bi]` indicates that there is an edge between nodes `ai` and `bi` in the tree. You are also given an integer array `restricted` which represents **restricted** nodes.

Return *the **maximum** number of nodes you can reach from node* `0` *without visiting a restricted node.*

Note that node `0` will **not** be a restricted node.

 

**Example 1:**

![img](https://cdn.jsdelivr.net/gh/huxingyi1997/my_img/img/20220808075740.png)

```
Input: n = 7, edges = [[0,1],[1,2],[3,1],[4,0],[0,5],[5,6]], restricted = [4,5]
Output: 4
Explanation: The diagram above shows the tree.
We have that [0,1,2,3] are the only nodes that can be reached from node 0 without visiting a restricted node.
```

**Example 2:**

![img](https://cdn.jsdelivr.net/gh/huxingyi1997/my_img/img/20220808075800.png)

```
Input: n = 7, edges = [[0,1],[0,2],[0,5],[0,4],[3,2],[6,5]], restricted = [4,2,1]
Output: 3
Explanation: The diagram above shows the tree.
We have that [0,5,6] are the only nodes that can be reached from node 0 without visiting a restricted node.
```

 

**Constraints:**

- `2 <= n <= 105`
- `edges.length == n - 1`
- `edges[i].length == 2`
- `0 <= ai, bi < n`
- `ai != bi`
- `edges` represents a valid tree.
- `1 <= restricted.length < n`
- `1 <= restricted[i] < n`
- All the values of `restricted` are **unique**.

Medium，BFS

```c++
class Solution {
public:
    int reachableNodes(int n, vector<vector<int>>& edges, vector<int>& restricted) {
        unordered_map<int, vector<int>> dic;
        for (vector<int> &edge: edges) {
            dic[edge[0]].push_back(edge[1]);
            dic[edge[1]].push_back(edge[0]);
        }
        unordered_set<int> restricted_set;
        for (int r: restricted) {
            restricted_set.insert(r);
        }
        int res = 1;
        unordered_set<int> visited;
        queue<int> q;
        visited.insert(0);
        q.push(0);
        while (!q.empty()) {
            int cur = q.front();
            q.pop();
            for (int node: dic[cur]) {
                if (!restricted_set.count(node) && !visited.count(node)) {
                    visited.insert(node);
                    q.push(node);
                    res++;
                }
            }
        }
        return res;
    }
};
```



### Failed: [2369. Check if There is a Valid Partition For The Array](https://leetcode.com/problems/check-if-there-is-a-valid-partition-for-the-array/)

You are given a **0-indexed** integer array `nums`. You have to partition the array into one or more **contiguous** subarrays.

We call a partition of the array **valid** if each of the obtained subarrays satisfies **one** of the following conditions:

1. The subarray consists of **exactly** `2` equal elements. For example, the subarray `[2,2]` is good.
2. The subarray consists of **exactly** `3` equal elements. For example, the subarray `[4,4,4]` is good.
3. The subarray consists of **exactly** `3` consecutive increasing elements, that is, the difference between adjacent elements is `1`. For example, the subarray `[3,4,5]` is good, but the subarray `[1,3,5]` is not.

Return `true` *if the array has **at least** one valid partition*. Otherwise, return `false`.

 

**Example 1:**

```
Input: nums = [4,4,4,5,6]
Output: true
Explanation: The array can be partitioned into the subarrays [4,4] and [4,5,6].
This partition is valid, so we return true.
```

**Example 2:**

```
Input: nums = [1,1,1,2]
Output: false
Explanation: There is no valid partition for this array.
```

 

**Constraints:**

- `2 <= nums.length <= 105`
- `1 <= nums[i] <= 106`

Medium，动态规划就好，别用状态机，太复杂

```c++
class Solution {
public:
    bool validPartition(vector<int>& nums) {
        int n = nums.size();
        vector<bool> dp(n + 1, false);
        dp[0] = true;
        for (int i = 1; i < n; i++) {
            if (dp[i - 1] && nums[i] == nums[i - 1]
                ||
                i > 1 && dp[i - 2] && nums[i] == nums[i - 1] && nums[i - 1] == nums[i - 2]
                ||
                i > 1 && dp[i - 2] && (nums[i] == nums[i - 1] + 1) && (nums[i - 1] == nums[i - 2] + 1)
               )
                dp[i + 1] = true;
        }
        return dp[n];
    }
};
```



### [2370. Longest Ideal Subsequence](https://leetcode.com/problems/longest-ideal-subsequence/)

You are given a string `s` consisting of lowercase letters and an integer `k`. We call a string `t` **ideal** if the following conditions are satisfied:

- `t` is a **subsequence** of the string `s`.
- The absolute difference in the alphabet order of every two **adjacent** letters in `t` is less than or equal to `k`.

Return *the length of the **longest** ideal string*.

A **subsequence** is a string that can be derived from another string by deleting some or no characters without changing the order of the remaining characters.

**Note** that the alphabet order is not cyclic. For example, the absolute difference in the alphabet order of `'a'` and `'z'` is `25`, not `1`.

 

**Example 1:**

```
Input: s = "acfgbd", k = 2
Output: 4
Explanation: The longest ideal string is "acbd". The length of this string is 4, so 4 is returned.
Note that "acfgbd" is not ideal because 'c' and 'f' have a difference of 3 in alphabet order.
```

**Example 2:**

```
Input: s = "abcd", k = 3
Output: 4
Explanation: The longest ideal string is "abcd". The length of this string is 4, so 4 is returned.
```

 

**Constraints:**

- `1 <= s.length <= 105`
- `0 <= k <= 25`
- `s` consists of lowercase English letters.

Medium，动态规划+map

```c++
class Solution {
public:
    int longestIdealString(string s, int k) {
        int n = s.size();
        vector<int> dp(n, 1);
        vector<int> last(26, -1);
        int res = 1;
        for (int i = 0; i < n; i++) {
            int num = s[i] - 'a';
            int min_num = max(0, num - k);
            int max_num = min(25, num + k);
            for (int j = min_num; j <= max_num; j++) {
                if (last[j] != -1) {
                    dp[i] = max(dp[i], dp[last[j]] + 1);
                }
            }
            last[num] = i;
            res = max(res, dp[i]);
        }
        return res;
    }
};
```

