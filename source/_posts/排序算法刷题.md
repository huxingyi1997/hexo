---
title:  排序算法刷题
date:  2021-03-09 00:02:39
categories: 
- 刷题
tags:
- javascript
- 数据结构和算法
- 排序算法
---

按照算法和数据结构进行分类，一起来刷题，用于自己在面试前查漏补缺。我的意向岗位是前端，选择用javascript来刷题，优点是动态语言，语法简单，缺点是遇见复杂数据结构会出现较难的写法，如堆、并查集，每题对应leetcode的题号。本篇是排序算法
<!-- more -->

## 专题部分

### 排序算法

#### [75. 颜色分类](https://leetcode-cn.com/problems/sort-colors/)

给定一个包含红色、白色和蓝色，一共 `n` 个元素的数组，**[原地](https://baike.baidu.com/item/原地算法)**对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。

此题中，我们使用整数 `0`、 `1` 和 `2` 分别表示红色、白色和蓝色。

**示例 1：**

```
输入：nums = [2,0,2,1,1,0]
输出：[0,0,1,1,2,2]
```

**示例 2：**

```
输入：nums = [2,0,1]
输出：[0,1,2]
```

**示例 3：**

```
输入：nums = [0]
输出：[0]
```

**示例 4：**

```
输入：nums = [1]
输出：[1]
```

**提示：**

- `n == nums.length`
- `1 <= n <= 300`
- `nums[i]` 为 `0`、`1` 或 `2`

**进阶：**

- 你可以不使用代码库中的排序函数来解决这道题吗？
- 你能想出一个仅使用常数空间的一趟扫描算法吗？

利用快速排序的思想，用双指针控制0和2

```javascript
/**
 * @param {number[]} nums
 * @return {void} Do not return anything, modify nums in-place instead.
 */
var sortColors = function(nums) {
    let left = -1, right = nums.length;
    // 当前位置
    let i = 0;
    // 下标如果遇到 right，说明已经排序完成
    while (i < right) {
        // 遇到0，与左指针交换，位置前进一步
        if (nums[i] == 0) {
            swap(nums, i++, ++left);
        } else if (nums[i] == 1) {
            // 遇到1，位置前进一步
            i++;
        } else {
            // 遇到2，与右指针交换，位置不变
            swap(nums, i, --right);
        }
    }
};
function swap(array, left, right) {
    let temp = array[right];
    array[right] = array[left];
    array[left] = temp;
}
```

#### 215.[数组中的第K个最大元素](https://leetcode-cn.com/problems/kth-largest-element-in-an-array/)

在未排序的数组中找到第 **k** 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。

**示例 1:**

```
输入: [3,2,1,5,6,4] 和 k = 2
输出: 5
```

**示例 2:**

```
输入: [3,2,3,1,2,4,5,5,6] 和 k = 4
输出: 4
```

**说明:**

你可以假设 k 总是有效的，且 1 ≤ k ≤ 数组的长度。

方法一，直接用库函数 时间复杂度：O(nlogn)，空间复杂度：O(logn)

```javascript
var findKthLargest = function(nums, k) {
    nums.sort((a, b) => b - a);
    return nums[k - 1];
};
```

方法二，构造k个元素的小顶堆

```javascript
/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number}
 */
var findKthLargest = function(nums, k) {
    // 从 nums 中取出前 k 个数，构建一个小顶堆
    buildHeap(nums, k);
    
    // 从 k 位开始遍历数组
    for(let i = k; i < nums.length; i++) {
        if(nums[0] < nums[i]) {
            // 替换并堆化
            nums[0] = nums[i];
            heapify(nums, k, 0);
        }
    }
    
    // 返回堆顶元素
    return nums[0];
};

// 原地建堆，从后往前，自上而下式建小顶堆
let buildHeap = (arr, k) => {
    if(k === 1) return;
    // 从最后一个非叶子节点开始，自上而下式堆化
    for(let i = Math.floor((k - 1) / 2); i >= 0; i--) {
        heapify(arr, k, i);
    }
}

// 堆化
let heapify = (arr, k, i) => {
    // 自上而下式堆化
    while(true) {
        let minIndex = i;
        // 比较和左节点
        if(2 * i + 1 < k && arr[2 * i + 1] < arr[i]) {
            minIndex = 2 * i + 1;
        }
        
        // 比较和右节点
        if(2 * i + 2 < k && arr[2 * i + 2] < arr[minIndex]) {
            minIndex = 2 * i + 2;
        }
        if (minIndex !== i) {
            // 交换和子节点种较小的那个
            swap(arr, i, minIndex);
            i = minIndex;
        } else {
            // 当前节点比左右节点都小，当前位置不用下沉
            break;
        }
    }
}

// 交换
let swap = (arr, i , j) => {
    let temp = arr[i];
    arr[i] = arr[j];
    arr[j] = temp;
}
```

方法三：快速排序 时间复杂度：平均时间复杂度O(n)，最坏情况时间复杂度为O(n<sup>2</sup>)，空间复杂度：O(1)

```javascript
/**
 * 在数组 nums 的子区间 [left, right] 执行 partition 操作，返回 nums[left] 排序以后应该在的位置
 * 在遍历过程中保持循环不变量的语义
 * 1、[left + 1, j] < nums[left]
 * 2、(j, i] >= nums[left]
 *
 * @param nums
 * @param left
 * @param right
 * @return
 */
function partition(nums, left, right) {
    let pivot = nums[left];
    let j = left;
    for (let i = left + 1; i <= right; i++) {
        if (nums[i] < pivot) {
            // 小于 pivot 的元素都被交换到前面
            j++;
            swap(nums, i, j);
        }
    }
     // 在之前遍历的过程中，满足 [left + 1, j] < pivot，并且 (j, i] >= pivot
     swap(nums, j, left);
     // 交换以后 [left, j - 1] < pivot, nums[j] = pivot, [j + 1, right] >= pivot
     return j;
};

function swap(nums, i, j) {
    let temp = nums[i];
    nums[i] = nums[j];
    nums[j] = temp;
/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number}
 */
var findKthLargest = function(nums, k) {
    let len = nums.length;
    let left = 0;
    let right = len - 1;

    // 转换一下，第 k 大元素的索引是 len - k
    let target = len - k;

    while(true) {
        let index = partition(nums, left, right);
        if (index == target) {
            return nums[target];
        } else if (index < target) {
            left = index + 1;
        } else {
            right = index - 1;
        }
    }
};
```
