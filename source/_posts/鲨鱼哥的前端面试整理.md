---
title:  鲨鱼哥的前端面试整理
date:  2021-07-18 17:35:40
categories: 
- 前端
tags:
- 鲨鱼哥
- 面试整理
- 综合
---

鲨鱼哥是个牛人，他这份总结是真的高频，原文请戳[前端高频面试题整理](https://juejin.cn/post/6844904148899463175)，其中一些知识点有很多独到的细节，一定要好好把握。
<!-- more -->

## 1. CSS基础

### 1.1 三栏布局问题（左右固定宽度 中间自适应）

#### 1.1.1 float + margin（浮动布局）

.html

```html
<div class="container">
    <div class="left">Left</div>
     <!-- 右栏部分要写在中间内容之前 -->
    <div class="right">Right</div>
    <div class="main">Main</div>
</div>
```

.css

```css
body, html, .container {
    height: 100%;
    padding:0;
    margin: 0;
}
/* 左边栏左浮动 */
.left{
    float: left;
    height: 100%;
    width: 200px;
    background: #333;
}
/* 中间栏自适应 */
.main {
    height: 100%;
    margin: 0 200px;
    background: red;
}
/* 右边栏右浮动 */
.right {
    float: right;
    height: 100%;
    width: 200px;
    background: #333;
}
```

优点：快捷 简单 兼容性较好
缺点：有局限性 脱离文档流 需要清除浮动等

#### 1.1.2 position（绝对布局）

.html

```html
<div class="container">
    <div class="left">Left</div>
    <div class="main">Main</div>
    <div class="right">Right</div>
</div>
```

.css

```css
body, html, .container {
    height: 100%;
    padding: 0;
    margin: 0;
    overflow: hidden;
}
/* 左右进行绝对定位 */
.left, .right {
    position: absolute;
    height: 100%;
    top: 0;
    background: #333;
}
.left {
    left: 0;
    width: 200px;
}
.right {
    right: 0;
    width: 200px;
}
/* 中间用margin空出左右元素所占的空间 */
.main {
    height: 100%;
    margin: 0 200px;
    background: red;
}
/* 或者中间也进行绝对定位 */
.main {
    position: absolute;
    height: 100%;
    left: 200px;
    right: 200px;
    background: red;
}
```

优点：简单粗暴
缺点：脱离文档流 高度未知会出现问题 可用性差

#### 1.1.3 flex（弹性盒子布局）

.html

```html
<div class="container">
    <div class="left">Left</div>
    <div class="main">Main</div>
    <div class="right">Right</div>
</div>
```

.css

```css
body, html {
    height: 100%;
    padding: 0;
    margin: 0;
    overflow: hidden;
}
.container {
    display: flex;
}
.left {
    width: 200px;
    background: red;
}
.main {
    flex: 1;
    background: blue;
}
.right {
    width:200px;
    background: red;
}
```

优点：比较完美 移动端首选
缺点：不兼容 ie9 及以下

#### 1.1.4 table(表格布局)

.html

```html
<div class="container">
    <div class="left">Left</div>
    <div class="main">Main</div>
    <div class="right">Right</div>
</div>
```

.css

```css
body, html{
    height: 100%;
    padding: 0;
    margin: 0;
    overflow: hidden;
}
.container {
    display: table;
    width: 100%;
}
.container>div {
    display: table-cell;
}
.left {
    width: 200px;
    background: red;
}
.main {
    background: blue;
}
.right {
    width: 200px;
    background: red;
}
```

优点：兼容性很好（ie8 及以上） 父元素高度会被子元素撑开（不担心高度塌陷）
缺点：seo 不友好 当其中一个单元格高度超出的时候，其他的单元格也是会跟着一起变高的

#### 1.1.5 Grid(网格布局)

.html

```html
<div class="container">
    <div class="left">Left</div>
    <div class="main">Main</div>
    <div class="right">Right</div>
</div>
```

.css

```css
body, html {
    height: 100%;
    padding: 0;
    margin: 0;
    overflow: hidden;
}
.container {
    display: grid;
    width: 100%;
    grid-template-rows: 100px;  /* 设置行高 */
    grid-template-columns: 200px auto 200px;  /* 设置列数属性 */
}
.left {
    background: red;
}
.main {
    background: blue;
}
.right {
    background:red;
}
```

优点：简单强大 解决二维布局问题
缺点：不兼容 ie9 及以下



### 1.2 CSS 盒模型

![img](https://cdn.jsdelivr.net/gh/huxingyi1997/my_img/img/20210718192417.png)

标准模型和 ie 模型

![img](https://cdn.jsdelivr.net/gh/huxingyi1997/my_img/img/20210718192603.png)



### 1.3 BFC

BFC（Block Formatting Context）块级格式化上下文，是 Web 页面中盒模型布局的 CSS 渲染模式，指一个独立的渲染区域或者说是一个隔离的独立容器。

#### 1.3.1 BFC 形成条件

1、浮动元素，float 除 none 以外的值；

2、定位元素，position（absolute，fixed）；

3、display 为以下其中之一的值 inline-block，table-cell，table-caption；

4、overflow 除了 visible 以外的值（hidden，auto，scroll）；

#### 1.3.2 BFC 特性

1.内部的 Box 会在垂直方向上一个接一个的放置；

2.垂直方向上的距离由margin 决定；（解决外边距重叠问题）

3.bfc 的区域不会与 float 的元素区域重叠；（防止浮动文字环绕）

4.计算 bfc 的高度时，浮动元素也参与计算；（清除浮动）

5.bfc 就是页面上的一个独立容器，容器里面的子元素不会影响外面元素；



## 2. DOM事件

### 2.1 事件级别

#### 2.1.1 DOM 0级 

写法：el.οnclick=function(){}

> 当希望为同一个元素/标签绑定多个同类型事件的时候（如给上面的这个btn元素绑定3个点击事件），是不被允许的。DOM0事件绑定，给元素的事件行为绑定方法，这些方法都是在当前元素事件行为的冒泡阶段(或者目标阶段)执行的。

#### 2.1.2 DOM 1级

*由于DOM 1级中没有事件的相关内容，所以没有DOM 1级事件*

#### 2.1.3 DOM 2级

DOM 2级 写法：el.addEventListener(event-name, callback, useCapture)

> event-name: 事件名称，可以是标准的DOM事件

> callback: 回调函数，当事件触发时，函数会被注入一个参数为当前的事件对象 event

> useCapture: 默认是false，代表事件句柄在冒泡阶段执行

#### 2.1.4 DOM 3级

DOM 3级 写法和DOM2级一致 只是在DOM 2级事件的基础上添加了更多的事件类型

> UI事件，当用户与页面上的元素交互时触发，如：load、scroll

> 焦点事件，当元素获得或失去焦点时触发，如：blur、focus

> 鼠标事件，当用户通过鼠标在页面执行操作时触发如：dblclick、mouseup

> 滚轮事件，当使用鼠标滚轮或类似设备时触发，如：mousewheel

> 文本事件，当在文档中输入文本时触发，如：textInput

> 键盘事件，当用户通过键盘在页面上执行操作时触发，如：keydown、keypress

> 合成事件，当为IME（输入法编辑器）输入字符时触发，如：compositionstart

> 变动事件，当底层DOM结构发生变化时触发，如：DOMsubtreeModified

> 同时DOM3级事件也允许使用者自定义一些事件。



### 2.2 DOM事件模型 事件流

事件模型分为：捕获和冒泡

事件流：

（1）捕获阶段：事件从window对象自上而下向目标节点传播的阶段；

（2）目标阶段：真正的目标节点正在处理事件的阶段；

（3）冒泡阶段：事件从目标节点自下而上向window对象传播的阶段。

![img](https://cdn.jsdelivr.net/gh/huxingyi1997/my_img/img/20210718194122.png)



### 2.3 事件委托（代理）

由于事件会在冒泡阶段向上传播到父节点，因此可以把子节点的监听函数定义在父节点上，由父节点的监听函数统一处理多个子元素的事件。这种方法叫做事件的代理（delegation）

优点：

1.减少内存消耗，提高性能(不需要为每一个子元素绑定事件)
2.动态绑定事件



### 2.4 Event对象使用

#### 2.4.1 阻止默认行为

event. preventDefault()

什么是默认事件呢？例如表单一点击提交按钮(submit)跳转页面、a标签默认页面跳转或是锚点定位等

#### 2.4.2 阻止冒泡

event.stopPropagation() 方法阻止事件冒泡到父元素，阻止任何父事件处理程序被执行

stopImmediatePropagation 既能阻止事件向父元素冒泡，也能阻止元素同事件类型的其它监听器被触发

#### 2.4.3 event.target & event.currentTarget

```html
<div id="a">
    aaaa
  <div id="b">
      bbbb
    <div id="c">
        cccc
      <div id="d">
          dddd
      </div>
    </div>
  </div>
</div>

<script>
    document.getElementById("a").addEventListener("click", function (e) {
        console.log(
            "target:" + e.target.id + "&currentTarget:" + e.currentTarget.id
        );
    });
    document.getElementById("b").addEventListener("click", function (e) {
        console.log(
            "target:" + e.target.id + "&currentTarget:" + e.currentTarget.id
        );
    });
    document.getElementById("c").addEventListener("click", function (e) {
        console.log(
            "target:" + e.target.id + "&currentTarget:" + e.currentTarget.id
        );
    });
    document.getElementById("d").addEventListener("click", function (e) {
        console.log(
            "target:" + e.target.id + "&currentTarget:" + e.currentTarget.id
        );
    });
</script>
```

当我们点击最里层的元素d的时候，会依次输出:

```sh
target:d&currentTarget:d
target:d&currentTarget:c
target:d&currentTarget:b
target:d&currentTarget:a
```

由上诉例子可知： event.currentTarget始终是监听事件者，而event.target是事件的真正发出者



### 2.5 自定义事件

创建事件, Event是无法传递参数的

```js
var event = new Event('build');
```

创建事件, CustomEvent是可以传递参数的

```js
var event = new CustomEvent('build', { detail: elem.dataset.time });
```

监听事件Listen for the event.

```js
elem.addEventListener('build', function (e) { /* ... */ }, false);
```

分发/触发事件Dispatch the event.

```js
elem.dispatchEvent(event);
```



### 2.6 手写EventEmitter(发布订阅模式--简单版)

```js
// 手写发布订阅模式 EventEmitter
class EventEmitter {
    constructor() {
        this.events = {};
    }
    // 实现订阅
    on(type, callBack) {
        if (!this.events) this.events = Object.create(null);
        if (!this.events[type]) {
            this.events[type] = [callBack];
        } else {
            this.events[type].push(callBack);
        }
    }
    // 删除订阅
    off(type, callBack) {
        if (!this.events[type]) return;
        this.events[type] = this.events[type].filter(item => {
            return item !== callBack;
        });
    }
    // 只执行一次订阅事件
    once(type, callBack) {
        function fn() {
            callBack();
            this.off(type, fn);
        }
        this.on(type, fn);
    }
    // 触发事件
    emit(type, ...rest) {
        this.events[type] && this.events[type].forEach(fn => fn.apply(this, rest));
    }
}
// 使用如下
const event = new EventEmitter();

const handle = (...rest) => {
    console.log(rest);
};

event.on("click", handle);

event.emit("click", 1, 2, 3, 4);

event.off("click", handle);

event.emit("click", 1, 2);

event.once("dbClick", () => {
    console.log(123456);
});
event.emit("dbClick");
event.emit("dbClick");
```



## 3. JS相关

### 3.1 创建对象方式

```js
// 1.对象字面量
let a = {
    name: 'xxx'
};

// 2.构造函数
function Person(name){
    this.name = name;
}
let b = new Person('xxx');

// 3.Object.create(proto, [propertiesObject])
// Object.create()方法创建的对象时，属性是在原型下面的
let c = Object.create({ name: 'xxx' });
```



### 3.2 原型链示意图

![img](https://cdn.jsdelivr.net/gh/huxingyi1997/my_img/img/20210718203649.png)



### 3.3 instanceof 原理

用来测试一个对象在其原型链中是否存在一个构造函数的 prototype 属性

```html
<script>
    function Person() {}
    function Foo() {}

    // 显示改变Foo.prototype指向Person的实例对象（原型继承）
    Foo.prototype = new Person();

    let a = new Foo();

    console.log(a.__proto__ === Foo.prototype); // true

    console.log(a instanceof Foo); // true

    console.log(Foo.prototype.__proto__ === Person.prototype); // true

    console.log(a instanceof Person); // true

    console.log(a instanceof Object); // true

    // 这个时候改变Foo.prototype的指向

    Foo.prototype = {};

    // Foo.prototype已经不在a的原型链上面了

    console.log(a.__proto__ === Foo.prototype); // false

    console.log(a instanceof Foo); // false

    // Person.prototype依然在a的原型链上面

    console.log(a instanceof Person);// true
</script>
```




### 3.4 new运算符原理

1、创建一个空对象

2、让空对象的\__proto__（IE没有该属性）成员指向了构造函数的prototype成员对象

3、使用apply调用构造器函数，属性和方法被添加到 this 引用的对象中

4、如果构造函数中没有返回其它对象，那么返回 this，即创建的这个的新对象，否则，返回构造函数中返回的对象

```js
function _new(func) {
    // 第一步 创建新对象
    let obj= {}; 
    // 第二步 空对象的_proto_指向了构造函数的prototype成员对象
    obj.__proto__ = func.prototype;
    // 一二步合并就相当于 let obj = Object.create(func.prototype);

    // 第三步 使用apply调用构造器函数，属性和方法被添加到 this 引用的对象中
    let result = func.apply(obj);
    if (result && (typeof (result) === "object" || typeof (result) === "function")) {
    	// 如果构造函数执行的结果返回的是一个对象，那么返回这个对象
        return result;
    }
    // 如果构造函数返回的不是一个对象，返回创建的新对象
    return obj;
}
```



### 3.5 JS实现继承的方式

```js
// 定义一个父类
function Father(name) {
    // 属性
    this.name = name || "father";
    // 实例方法
    this.sayName = function() {
        console.log(this.name);
    };
    this.color = ["red", "blue"];
}
// 原型方法
Father.prototype.age = 18;
Father.prototype.sayAge = function() {
    console.log(this.age);
};
```

#### 3.5.1 原型链继承

将父类的实例作为子类的原型

```js
function Son(name) {
    this.name = name || "son";
}

Son.prototype = new Father();

let s1 = new Son("s1");
let s2 = new Son("s2");

s1.color.push("black");

console.log(s1.name); // s1
console.log(s1.color); // ['red', 'blue', 'black']
console.log(s1.age); // 18
s1.sayAge(); // 18
console.log(s2.name); // s2
console.log(s2.color); // ['red', 'blue', 'black']
```

优点：
1. 简单，易于实现
2. 父类新增原型方法、原型属性，子类都能访问到

缺点：
1. 无法实现多继承，因为原型一次只能被一个实例更改
2. 来自原型对象的所有属性被所有实例共享（上诉例子中的color属性）
3. 创建子类实例时，无法向父构造函数传参

#### 3.5.2 构造继承继承

复制父类的实例属性给子类

```js
function Son(name) {
    Father.call(this, "我是传给父类的参数");
    this.name = name || "son";
}
let s = new Son("son");
console.log(s.name); // son
// s.sayAge(); // 抛出错误（无法继承父类原型方法）
s.sayName(); // son
console.log(s.age); // undefined （无法继承父类原型属性）
console.log(s instanceof Father); // false
console.log(s instanceof Son); // true
```

优点：
1. 解决了原型链继承中子类实例共享父类引用属性的问题
2. 创建子类实例时，可以向父类传递参数
3. 可以实现多继承（call多个父类对象）

缺点：
1. 实例并不是父类的实例，只是子类的实例
2. 只能继承父类实例的属性和方法，不能继承其原型上的属性和方法
3. 无法实现函数复用，每个子类都有父类实例函数的副本，影响性能

#### 3.5.3 组合继承

将原型链和借用构造函数的技术组合到一块。使用原型链实现对原型属性和方法的继承，而通过构造函数来实现对实例属性的继承

```js
function Son(name) {
    // 第一次调用父类构造器 子类实例增加父类实例
    Father.call(this, "我是传给父类的参数");
    this.name = name || "son";
}
// 经过new运算符 第二次调用父类构造器 子类原型也增加了父类实例
Son.prototype = new Father();

let s = new Son("son");
console.log(s.name); // son
s.sayAge(); // 18
s.sayName(); // son
console.log(s.age); // 18
console.log(s instanceof Father); // true
console.log(s instanceof Son); // true
console.log(s.constructor === Father); // true
console.log(s.constructor === Son); // false
```

优点：
1. 弥补了构造继承的缺点，现在既可以继承实例的属性和方法，也可以继承原型的属性和方法
2. 既是子类的实例，也是父类的实例
3. 可以向父类传递参数
4. 函数可以复用

缺点：
1. 调用了两次父类构造函数，生成了两份实例
2. constructor指向问题

#### 3.5.4 实例继承

为父类实例添加新特征，作为子类实例返回

```js
function Son(name) {
    let f = new Father('传给父类的参数');
    f.name = name || 'son';
    return f;
}

let s = new Son("son"); //或者直接调用子类构造函数 let s = Son("son");
console.log(s.name); // son
s.sayAge(); // 18
s.sayName(); // son
console.log(s.age); // 18
console.log(s instanceof Father); // true
console.log(s instanceof Son); // false
console.log(s.constructor === Father); // true
console.log(s.constructor === Son); // false
```

优点：
1. 不限制调用方式，不管是new 子类()还是子类(),返回的对象具有相同的效果

缺点：
1. 实例是父类的实例，不是子类的实例
2. 不支持多继承

#### 3.5.5 拷贝继承

对父类实例中的的方法与属性拷贝给子类的原型

```js
function Son(name) {
    let f = new Father("传给父类的参数");
    for (let k in f) {
        Son.prototype[k] = f[k];
    }
    Son.prototype.name = name;
}

let s = new Son("son");
console.log(s.name); // son
s.sayAge(); // 18
s.sayName(); // son
console.log(s.age); // 18
console.log(s instanceof Father); // false
console.log(s instanceof Son); // true
console.log(s.constructor === Father); // false
console.log(s.constructor === Son); // true
```

优点：
1. 支持多继承

缺点：
1. 效率低，性能差，占用内存高（因为需要拷贝父类属性）
2. 无法获取父类不可枚举的方法（不可枚举的方法，不能使用for-in访问到)

#### 3.5.6 寄生组合继承

通过寄生方式，砍掉父类的实例属性，避免了组合继承生成两份实例的缺点

```js
function Son(name) {
    Father.call(this);
    this.name = name || "son";
}

// 方法一  自己动手创建一个中间类
// (function() {
//   let NoneFun = function() {};
//   NoneFun.prototype = Father.prototype;
//   Son.prototype = new NoneFun();
//   Son.prototype.constructor = Son;
// })();

// 方法二  直接借用Object.create()方法
Son.prototype = Object.create(Father.prototype);
// 修复构造函数指向
Son.prototype.constructor = Son;

let s = new Son("son");
console.log(s.name); // son
s.sayAge(); // 18
s.sayName(); // son
console.log(s.age); // 18
console.log(s instanceof Father); // true
console.log(s instanceof Son); // true
console.log(s.constructor === Father); // false
console.log(s.constructor === Son); // true
```

优点：
1. 比较完美（js实现继承首选方式）

缺点：

1. 实现起来较为复杂（可通过Object.create简化）

#### 3.5.7 es6--Class继承

使用extends表明继承自哪个父类，并且在子类构造函数中必须调用super

```js
class Son extends Father {
    constructor(name) {
        super(name);
        this.name = name || "son";
    }
}

let s = new Son("son");
console.log(s.name); // son
s.sayAge(); // 18
s.sayName(); // son
console.log(s.age); // 18
console.log(s instanceof Father); // true
console.log(s instanceof Son); // true
console.log(s.constructor === Father); // false
console.log(s.constructor === Son); // true
```



### 3.6 JS防抖与节流(性能优化)

**防抖**：动作停止后的时间超过设定的时间时执行一次函数。注意：这里的动作停止表示你停止了触发这个函数，从这个时间点开始计算，当间隔时间等于你设定时间，才会执行里面的回调函数。如果你一直在触发这个函数并且两次触发间隔小于设定时间，则函数一直不会执行。

简单实现：
```js
function debance(fn, delay) {
    let timer = null;
    return () => {
        if (timer) {
            clearTimeout(timer);
        }
        timer = setTimeout(() => {
            fn();
        }, delay);
    };
}

window.addEventListener(
    "scroll",
    debance(() => {
        console.log(111);
    }, 1000)
);
```
防抖应用场景：
1. search搜索联想，用户在不断输入值时，用防抖来节约请求资源
2. window触发resize的时候，不断的调整浏览器窗口大小会不断的触发这个事件，用防抖来让其只触发一次

**节流**：一定时间内执行的操作只执行一次，也就是说即预先设定一个执行周期，当调用动作的时刻大于等于执行周期则执行该动作，然后进入下一个新周期。

简单实现：

```js
// 方法一：设置一个标志
function throttle(fn, delay) {
    let flag = true;
    return () => {
        if (!flag) return;
        flag = false;
        timer = setTimeout(() => {
            fn();
            flag = true;
        }, delay);
    };
}
// 方法二：使用时间戳
function throttle(fn, delay) {
    let startTime = new Date();
    return () => {
        let endTime = new Date();
        if (endTime - startTime >= delay) {
            fn();
            startTime=endTime;
        } else {
            return;
        }
    };
}
window.addEventListener(
    "scroll",
    throttle(() => {
        console.log(111);
    }, 1000)
);
```

节流应用场景：
1. 鼠标不断点击触发，mousedown(单位时间内只触发一次)
2. 监听滚动事件，比如是否滑到底部自动加载更多（懒加载），用throttle来判断

### 3.7 JS运行机制

#### 3.7.1 JS为啥是单线程

js作为浏览器脚本语言，其主要用途是与用户互动，以及操作DOM。这就决定了它只能是单线程，否则会带来很复杂的同步问题。（假设JavaScript同时有两个线程，一个线程在某个DOM节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？）

#### 3.7.2 JS同步任务和异步任务

![事件循环](https://cdn.jsdelivr.net/gh/huxingyi1997/my_img/img/20210718214518.png)

JavaScript语言的一大特点就是单线程，也就是说，同一个时间只能做一件事。如果前一个任务耗时很长，后一个任务就不得不一直等着。JavaScript语言的设计者意识到这个问题，将所有任务分成两种，一种是同步任务（synchronous），另一种是异步任务（asynchronous）

> 同步任务指的是，在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务；

> 异步任务指的是，不进入主线程、而进入"任务队列"（task queue）的任务，只有"任务队列"通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行

#### 3.7.3 任务队列（消息队列）

任务队列中存着的是异步任务，这些异步任务一定要等到执行栈清空后才会执行。

异步任务，会先到事件列表中注册函数。如果事件列表中的事件触发了，会将这个函数移入到任务队列中（DOM操作对应DOM事件，资源加载操作对应加载事件，定时器操作可以看做对应一个“时间到了”的事件）

#### 3.7.4 宏任务与微任务

![宏任务和微任务](https://cdn.jsdelivr.net/gh/huxingyi1997/my_img/img/20210718215354.png)

macro-task(宏任务)：包括整体代码script，setTimeout，setInterval， setImmediate, I/O, UI rendering

micro-task(微任务)：Promise，process.nextTick，MutationObserver

微任务意义：

> 减少更新时的渲染次数 因为根据HTML标准，会在宏任务执行结束之后，在下一个宏任务开始执行之前，UI都会重新渲染。如果在microtask中就完成数据更新，当 macro-task结束就可以得到最新的UI了。如果新建一个 macro-task来做数据更新的话，那么渲染会执行两次

扩展阅读： [全面解析Vue.nextTick实现原理](https://juejin.cn/post/6844903590293684231)

#### 3.7.5 Event Loop(事件循环)

![事件循环](https://cdn.jsdelivr.net/gh/huxingyi1997/my_img/img/20210718220149.png)

1. 整体的script(作为第一个宏任务)开始执行的时候，会把所有代码分为两部分：“同步任务”、“异步任务”；
2. 同步任务会直接进入主线程依次执行；
3. 异步任务会再分为宏任务和微任务；
4. 宏任务进入到Event Table中，并在里面注册回调函数，每当指定的事件完成时，Event Table会将这个函数移到Event Queue中；
5. 微任务也会进入到另一个Event Table中，并在里面注册回调函数，每当指定的事件完成时，Event Table会将这个函数移到Event Queue中；
6. 当主线程内的任务执行完毕，主线程为空时，会检查微任务的Event Queue，如果有任务，就全部执行，如果没有就执行下一个宏任务；
7. 上述过程会不断重复，这就是Event Loop事件循环；

#### 3.7.6 一图总结（事件循环、执行栈、任务队列、宏任务、微任务）

![js事件循环](https://cdn.jsdelivr.net/gh/huxingyi1997/my_img/img/20210718221027.png)

#### 3.7.7 经典面试题

```js
console.log(1);

setTimeout(()=>{
    console.log(2);   
    new Promise((resolve,reject)=>{
        console.log(3);
        resolve()
    }).then(res=>{
        console.log(4); 
    })
})

new Promise((resolve,reject)=>{
    resolve()
}).then(res=>{
    console.log(5); 
}).then(res=>{
    console.log(6);

})

new Promise((resolve,reject)=>{
    console.log(7);
    resolve()
}).then(res=>{
    console.log(8); 
}).then(res=>{
    console.log(9);

})

setTimeout(()=>{
    console.log(10);   
    new Promise((resolve,reject)=>{
        console.log(11);
        resolve()
    }).then(res=>{
        console.log(12); 
    })
})

console.log(13);
```

依次输出

![输出](https://cdn.jsdelivr.net/gh/huxingyi1997/my_img/img/20210718221140.png)



### 3.8 如何取消promise

```js
// 方法一 取消promise方法   promise.race方法
function wrap(p) {
    let obj = {};
    let p1 = new Promise((resolve, reject) => {
        obj.resolve = resolve;
        obj.reject = reject;
    });
    obj.promise = Promise.race([p1, p]);
    return obj;
}

let promise = new Promise((resolve, reject) => {
    setTimeout(() => {
        resolve(123);
    }, 1000);
});
let obj = wrap(promise);
obj.promise.then(res => {
    console.log(res);
});
obj.resolve("请求被拦截了");

obj.reject("请求被拒绝了");


// 方法二 取消promise方法   新包装一个可操控的promise

function wrap(p) {
    let res = null;
    let abort = null;

    let p1 = new Promise((resolve, reject) => {
        res = resolve;
        abort = reject;
    });

    p1.abort = abort;
    p.then(res, abort);

    return p1;
}

let promise = new Promise((resolve, reject) => {
    setTimeout(() => {
        resolve(123);
    }, 1000);
});
let obj = wrap(promise);
obj.then(res => {
    console.log(res);
});
obj.abort("请求被拦截");
```



## 4.HTTP协议相关

HTTP(Hyper Text Transfer Protocol)<超文本传输协议>的缩写.是用于从WWW服务器传输超文本到本地浏览器的传输协议.HTTP是一个应用层协议,由请求和响应构成,是一个标准的个客户端和服务器模型

### 4.1 特点

1. 基于请求/响应模型的协议
2. 简单快速
3. 灵活
4. 无连接
5. 无状态

### 4.2 HTTP报文

请求报文：

![请求报文](https://cdn.jsdelivr.net/gh/huxingyi1997/my_img/img/20210718235748.png)

响应报文：

![响应报文](https://cdn.jsdelivr.net/gh/huxingyi1997/my_img/img/20210719000005.png)

### 4.3 HTTP方法

![HTTP请求方法](https://cdn.jsdelivr.net/gh/huxingyi1997/my_img/img/20210719000300.png)

get和post区别：

> GET请求会被浏览器主动cache，而POST不会，除非手动设置
>
> get把请求的参数放在url上，即HTTP协议头上 post把参数放在HTTP的包体内
>
> Get 方式传输的数据量非常小，一般限制在 2 KB 左右，但是执行效率却比 >Post 方法好；而 Post
> 方式传递的数据量相对较大，它是等待服务器来读取数>据，不过也有字节限制（实际上IIS4中最大量为80KB，IIS5中为100KB），这是为>了避免对服务器用大量数据进行恶意攻击
>
> GET请求只能进行url编码，而POST支持多种编码方式
>
> GET产生的URL地址可以加入书签，而POST不可以
>
> GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留
>
> GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息

### 4.4 HTTP状态码

状态码：由3位数字组成，第一个数字定义了响应的类别

1xx：指示信息，表示请求已接收，继续处理

2xx：成功，表示请求已被成功接受，处理。

